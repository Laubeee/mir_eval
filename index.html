
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>mir_eval Documentation &#8212; mir_eval 0.7 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/classic.css" />
    
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Changes" href="changes.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="changes.html" title="Changes"
             accesskey="N">next</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">mir_eval 0.7 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="docutils literal notranslate"><span class="pre">mir_eval</span></code> Documentation</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="mir-eval-documentation">
<h1><code class="docutils literal notranslate"><span class="pre">mir_eval</span></code> Documentation<a class="headerlink" href="#mir-eval-documentation" title="Permalink to this headline">¶</a></h1>
<p><code class="docutils literal notranslate"><span class="pre">mir_eval</span></code> is a Python library which provides a transparent, standaridized, and straightforward way to evaluate Music Information Retrieval systems.</p>
<p>If you use <code class="docutils literal notranslate"><span class="pre">mir_eval</span></code> in a research project, please cite the following paper:</p>
<ol class="upperalpha simple" start="3">
<li><p>Raffel, B. McFee, E. J. Humphrey, J. Salamon, O. Nieto, D. Liang, and D. P. W. Ellis, <a class="reference external" href="http://colinraffel.com/publications/ismir2014mir_eval.pdf">“mir_eval: A Transparent Implementation of Common MIR Metrics”</a>, Proceedings of the 15th International Conference on Music Information Retrieval, 2014.</p></li>
</ol>
<section id="installing-mir-eval">
<span id="installation"></span><h2>Installing <code class="docutils literal notranslate"><span class="pre">mir_eval</span></code><a class="headerlink" href="#installing-mir-eval" title="Permalink to this headline">¶</a></h2>
<p>The simplest way to install <code class="docutils literal notranslate"><span class="pre">mir_eval</span></code> is by using <code class="docutils literal notranslate"><span class="pre">pip</span></code>, which will also install the required dependencies if needed.
To install <code class="docutils literal notranslate"><span class="pre">mir_eval</span></code> using <code class="docutils literal notranslate"><span class="pre">pip</span></code>, simply run</p>
<p><code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">mir_eval</span></code></p>
<p>Alternatively, you can install <code class="docutils literal notranslate"><span class="pre">mir_eval</span></code> from source by first installing the dependencies and then running</p>
<p><code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">install</span></code></p>
<p>from the source directory.</p>
<p>If you don’t use Python and want to get started as quickly as possible, you might consider using <a class="reference external" href="https://store.continuum.io/cshop/anaconda/">Anaconda</a> which makes it easy to install a Python environment which can run <code class="docutils literal notranslate"><span class="pre">mir_eval</span></code>.</p>
</section>
<section id="using-mir-eval">
<h2>Using <code class="docutils literal notranslate"><span class="pre">mir_eval</span></code><a class="headerlink" href="#using-mir-eval" title="Permalink to this headline">¶</a></h2>
<p>Once you’ve installed <code class="docutils literal notranslate"><span class="pre">mir_eval</span></code> (see <a class="reference internal" href="#installation"><span class="std std-ref">Installing mir_eval</span></a>), you can import it in your Python code as follows:</p>
<p><code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">mir_eval</span></code></p>
<p>From here, you will typically either load in data and call the <code class="docutils literal notranslate"><span class="pre">evaluate()</span></code> function from the appropriate submodule like so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference_beats.txt&#39;</span><span class="p">)</span>
<span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated_beats.txt&#39;</span><span class="p">)</span>
<span class="c1"># Scores will be a dict containing scores for all of the metrics</span>
<span class="c1"># implemented in mir_eval.beat.  The keys are metric names</span>
<span class="c1"># and values are the scores achieved</span>
<span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span> <span class="n">estimated_beats</span><span class="p">)</span>
</pre></div>
</div>
<p>or you’ll load in the data, do some preprocessing, and call specific metric functions from the appropriate submodule like so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference_beats.txt&#39;</span><span class="p">)</span>
<span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated_beats.txt&#39;</span><span class="p">)</span>
<span class="c1"># Crop out beats before 5s, a common preprocessing step</span>
<span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">)</span>
<span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">estimated_beats</span><span class="p">)</span>
<span class="c1"># Compute the F-measure metric and store it in f_measure</span>
<span class="n">f_measure</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">f_measure</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span> <span class="n">estimated_beats</span><span class="p">)</span>
</pre></div>
</div>
<p>The documentation for each metric function, found in the <a class="reference internal" href="#mir-eval"><span class="std std-ref">mir_eval</span></a> section below, contains further usage information.</p>
<p>Alternatively, you can use the evaluator scripts which allow you to run evaluation from the command line, without writing any code.
These scripts are are available here:</p>
<p><a class="reference external" href="https://github.com/craffel/mir_evaluators">https://github.com/craffel/mir_evaluators</a></p>
</section>
<section id="mir-eval">
<span id="id1"></span><h2><code class="docutils literal notranslate"><span class="pre">mir_eval</span></code><a class="headerlink" href="#mir-eval" title="Permalink to this headline">¶</a></h2>
<p>The structure of the <code class="docutils literal notranslate"><span class="pre">mir_eval</span></code> Python module is as follows:
Each MIR task for which evaluation metrics are included in <code class="docutils literal notranslate"><span class="pre">mir_eval</span></code> is given its own submodule, and each metric is defined as a separate function in each submodule.
Every metric function includes detailed documentation, example usage, input validation, and references to the original paper which defined the metric (see the subsections below).
The task submodules also all contain a function <code class="docutils literal notranslate"><span class="pre">evaluate()</span></code>, which takes as input reference and estimated annotations and returns a dictionary of scores for all of the metrics implemented (for casual users, this is the place to start).
Finally, each task submodule also includes functions for common data pre-processing steps.</p>
<p><code class="docutils literal notranslate"><span class="pre">mir_eval</span></code> also includes the following additional submodules:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#module-mir_eval.io" title="mir_eval.io"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.io</span></code></a> which contains convenience functions for loading in task-specific data from common file formats</p></li>
<li><p><a class="reference internal" href="#module-mir_eval.util" title="mir_eval.util"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.util</span></code></a> which includes miscellaneous functionality shared across the submodules</p></li>
<li><p><a class="reference internal" href="#module-mir_eval.sonify" title="mir_eval.sonify"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.sonify</span></code></a> which implements some simple methods for synthesizing annotations of various formats for “evaluation by ear”.</p></li>
<li><p><a class="reference internal" href="#module-mir_eval.display" title="mir_eval.display"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.display</span></code></a> which provides functions for plotting annotations for various tasks.</p></li>
</ul>
<p>The following subsections document each submodule.</p>
<section id="module-mir_eval.beat">
<span id="mir-eval-beat"></span><h3><a class="reference internal" href="#module-mir_eval.beat" title="mir_eval.beat"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.beat</span></code></a><a class="headerlink" href="#module-mir_eval.beat" title="Permalink to this headline">¶</a></h3>
<p>The aim of a beat detection algorithm is to report the times at which a typical
human listener might tap their foot to a piece of music. As a result, most
metrics for evaluating the performance of beat tracking systems involve
computing the error between the estimated beat times and some reference list of
beat locations. Many metrics additionally compare the beat sequences at
different metric levels in order to deal with the ambiguity of tempo.</p>
<dl class="simple">
<dt>Based on the methods described in:</dt><dd><p>Matthew E. P. Davies,  Norberto Degara, and Mark D. Plumbley.
“Evaluation Methods for Musical Audio Beat Tracking Algorithms”,
Queen Mary University of London Technical Report C4DM-TR-09-06
London, United Kingdom, 8 October 2009.</p>
</dd>
<dt>See also the Beat Evaluation Toolbox:</dt><dd><p><a class="reference external" href="https://code.soundsoftware.ac.uk/projects/beat-evaluation/">https://code.soundsoftware.ac.uk/projects/beat-evaluation/</a></p>
</dd>
</dl>
<section id="conventions">
<h4>Conventions<a class="headerlink" href="#conventions" title="Permalink to this headline">¶</a></h4>
<p>Beat times should be provided in the form of a 1-dimensional array of beat
times in seconds in increasing order.  Typically, any beats which occur before
5s are ignored; this can be accomplished using
<a class="reference internal" href="#mir_eval.beat.trim_beats" title="mir_eval.beat.trim_beats"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.beat.trim_beats()</span></code></a>.</p>
</section>
<section id="metrics">
<h4>Metrics<a class="headerlink" href="#metrics" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><a class="reference internal" href="#mir_eval.beat.f_measure" title="mir_eval.beat.f_measure"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.beat.f_measure()</span></code></a>: The F-measure of the beat sequence, where an
estimated beat is considered correct if it is sufficiently close to a
reference beat</p></li>
<li><p><a class="reference internal" href="#mir_eval.beat.cemgil" title="mir_eval.beat.cemgil"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.beat.cemgil()</span></code></a>: Cemgil’s score, which computes the sum of
Gaussian errors for each beat</p></li>
<li><p><a class="reference internal" href="#mir_eval.beat.goto" title="mir_eval.beat.goto"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.beat.goto()</span></code></a>: Goto’s score, a binary score which is 1 when at
least 25% of the estimated beat sequence closely matches the reference beat
sequence</p></li>
<li><p><a class="reference internal" href="#mir_eval.beat.p_score" title="mir_eval.beat.p_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.beat.p_score()</span></code></a>: McKinney’s P-score, which computes the
cross-correlation of the estimated and reference beat sequences represented
as impulse trains</p></li>
<li><p><a class="reference internal" href="#mir_eval.beat.continuity" title="mir_eval.beat.continuity"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.beat.continuity()</span></code></a>: Continuity-based scores which compute the
proportion of the beat sequence which is continuously correct</p></li>
<li><p><a class="reference internal" href="#mir_eval.beat.information_gain" title="mir_eval.beat.information_gain"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.beat.information_gain()</span></code></a>: The Information Gain of a normalized
beat error histogram over a uniform distribution</p></li>
</ul>
<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.beat.trim_beats">
<span class="sig-prename descclassname"><span class="pre">mir_eval.beat.</span></span><span class="sig-name descname"><span class="pre">trim_beats</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beats</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_beat_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.beat.trim_beats" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes beats before min_beat_time.  A common preprocessing step.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>beats</strong><span class="classifier">np.ndarray</span></dt><dd><p>Array of beat times in seconds.</p>
</dd>
<dt><strong>min_beat_time</strong><span class="classifier">float</span></dt><dd><p>Minimum beat time to allow
(Default value = 5.)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>beats_trimmed</strong><span class="classifier">np.ndarray</span></dt><dd><p>Trimmed beat array.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.beat.validate">
<span class="sig-prename descclassname"><span class="pre">mir_eval.beat.</span></span><span class="sig-name descname"><span class="pre">validate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_beats</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_beats</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.beat.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a metric look like valid beat time
arrays, and throws helpful errors if not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_beats</strong><span class="classifier">np.ndarray</span></dt><dd><p>reference beat times, in seconds</p>
</dd>
<dt><strong>estimated_beats</strong><span class="classifier">np.ndarray</span></dt><dd><p>estimated beat times, in seconds</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.beat.f_measure">
<span class="sig-prename descclassname"><span class="pre">mir_eval.beat.</span></span><span class="sig-name descname"><span class="pre">f_measure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_beats</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_beats</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_measure_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.07</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.beat.f_measure" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the F-measure of correct vs incorrectly predicted beats.
“Correctness” is determined over a small window.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_beats</strong><span class="classifier">np.ndarray</span></dt><dd><p>reference beat times, in seconds</p>
</dd>
<dt><strong>estimated_beats</strong><span class="classifier">np.ndarray</span></dt><dd><p>estimated beat times, in seconds</p>
</dd>
<dt><strong>f_measure_threshold</strong><span class="classifier">float</span></dt><dd><p>Window size, in seconds
(Default value = 0.07)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>f_score</strong><span class="classifier">float</span></dt><dd><p>The computed F-measure score</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">estimated_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_measure</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">f_measure</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span>
<span class="go">                                        estimated_beats)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.beat.cemgil">
<span class="sig-prename descclassname"><span class="pre">mir_eval.beat.</span></span><span class="sig-name descname"><span class="pre">cemgil</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_beats</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_beats</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cemgil_sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.04</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.beat.cemgil" title="Permalink to this definition">¶</a></dt>
<dd><p>Cemgil’s score, computes a gaussian error of each estimated beat.
Compares against the original beat times and all metrical variations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_beats</strong><span class="classifier">np.ndarray</span></dt><dd><p>reference beat times, in seconds</p>
</dd>
<dt><strong>estimated_beats</strong><span class="classifier">np.ndarray</span></dt><dd><p>query beat times, in seconds</p>
</dd>
<dt><strong>cemgil_sigma</strong><span class="classifier">float</span></dt><dd><p>Sigma parameter of gaussian error windows
(Default value = 0.04)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cemgil_score</strong><span class="classifier">float</span></dt><dd><p>Cemgil’s score for the original reference beats</p>
</dd>
<dt><strong>cemgil_max</strong><span class="classifier">float</span></dt><dd><p>The best Cemgil score for all metrical variations</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">estimated_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cemgil_score</span><span class="p">,</span> <span class="n">cemgil_max</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">cemgil</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span>
<span class="go">                                                    estimated_beats)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.beat.goto">
<span class="sig-prename descclassname"><span class="pre">mir_eval.beat.</span></span><span class="sig-name descname"><span class="pre">goto</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_beats</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_beats</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">goto_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.35</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">goto_mu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">goto_sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.beat.goto" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate Goto’s score, a binary 1 or 0 depending on some specific
heuristic criteria</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_beats</strong><span class="classifier">np.ndarray</span></dt><dd><p>reference beat times, in seconds</p>
</dd>
<dt><strong>estimated_beats</strong><span class="classifier">np.ndarray</span></dt><dd><p>query beat times, in seconds</p>
</dd>
<dt><strong>goto_threshold</strong><span class="classifier">float</span></dt><dd><p>Threshold of beat error for a beat to be “correct”
(Default value = 0.35)</p>
</dd>
<dt><strong>goto_mu</strong><span class="classifier">float</span></dt><dd><p>The mean of the beat errors in the continuously correct
track must be less than this
(Default value = 0.2)</p>
</dd>
<dt><strong>goto_sigma</strong><span class="classifier">float</span></dt><dd><p>The std of the beat errors in the continuously correct track must
be less than this
(Default value = 0.2)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>goto_score</strong><span class="classifier">float</span></dt><dd><p>Either 1.0 or 0.0 if some specific criteria are met</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">estimated_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">goto_score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">goto</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span> <span class="n">estimated_beats</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.beat.p_score">
<span class="sig-prename descclassname"><span class="pre">mir_eval.beat.</span></span><span class="sig-name descname"><span class="pre">p_score</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_beats</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_beats</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_score_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.beat.p_score" title="Permalink to this definition">¶</a></dt>
<dd><p>Get McKinney’s P-score.
Based on the autocorrelation of the reference and estimated beats</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_beats</strong><span class="classifier">np.ndarray</span></dt><dd><p>reference beat times, in seconds</p>
</dd>
<dt><strong>estimated_beats</strong><span class="classifier">np.ndarray</span></dt><dd><p>query beat times, in seconds</p>
</dd>
<dt><strong>p_score_threshold</strong><span class="classifier">float</span></dt><dd><p>Window size will be
<code class="docutils literal notranslate"><span class="pre">p_score_threshold*np.median(inter_annotation_intervals)</span></code>,
(Default value = 0.2)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>correlation</strong><span class="classifier">float</span></dt><dd><p>McKinney’s P-score</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">estimated_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">p_score</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span> <span class="n">estimated_beats</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.beat.continuity">
<span class="sig-prename descclassname"><span class="pre">mir_eval.beat.</span></span><span class="sig-name descname"><span class="pre">continuity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_beats</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_beats</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">continuity_phase_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.175</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">continuity_period_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.175</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.beat.continuity" title="Permalink to this definition">¶</a></dt>
<dd><p>Get metrics based on how much of the estimated beat sequence is
continually correct.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_beats</strong><span class="classifier">np.ndarray</span></dt><dd><p>reference beat times, in seconds</p>
</dd>
<dt><strong>estimated_beats</strong><span class="classifier">np.ndarray</span></dt><dd><p>query beat times, in seconds</p>
</dd>
<dt><strong>continuity_phase_threshold</strong><span class="classifier">float</span></dt><dd><p>Allowable ratio of how far is the estimated beat
can be from the reference beat
(Default value = 0.175)</p>
</dd>
<dt><strong>continuity_period_threshold</strong><span class="classifier">float</span></dt><dd><p>Allowable distance between the inter-beat-interval
and the inter-annotation-interval
(Default value = 0.175)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>CMLc</strong><span class="classifier">float</span></dt><dd><p>Correct metric level, continuous accuracy</p>
</dd>
<dt><strong>CMLt</strong><span class="classifier">float</span></dt><dd><p>Correct metric level, total accuracy (continuity not required)</p>
</dd>
<dt><strong>AMLc</strong><span class="classifier">float</span></dt><dd><p>Any metric level, continuous accuracy</p>
</dd>
<dt><strong>AMLt</strong><span class="classifier">float</span></dt><dd><p>Any metric level, total accuracy (continuity not required)</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">estimated_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CMLc</span><span class="p">,</span> <span class="n">CMLt</span><span class="p">,</span> <span class="n">AMLc</span><span class="p">,</span> <span class="n">AMLt</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">continuity</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span>
<span class="go">                                                      estimated_beats)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.beat.information_gain">
<span class="sig-prename descclassname"><span class="pre">mir_eval.beat.</span></span><span class="sig-name descname"><span class="pre">information_gain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_beats</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_beats</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">41</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.beat.information_gain" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the information gain - K-L divergence of the beat error histogram
to a uniform histogram</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_beats</strong><span class="classifier">np.ndarray</span></dt><dd><p>reference beat times, in seconds</p>
</dd>
<dt><strong>estimated_beats</strong><span class="classifier">np.ndarray</span></dt><dd><p>query beat times, in seconds</p>
</dd>
<dt><strong>bins</strong><span class="classifier">int</span></dt><dd><p>Number of bins in the beat error histogram
(Default value = 41)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>information_gain_score</strong><span class="classifier">float</span></dt><dd><p>Entropy of beat error histogram</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">estimated_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">information_gain</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">information_gain</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span>
<span class="go">                                                      estimated_beats)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.beat.evaluate">
<span class="sig-prename descclassname"><span class="pre">mir_eval.beat.</span></span><span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_beats</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_beats</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.beat.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all metrics for the given reference and estimated annotations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_beats</strong><span class="classifier">np.ndarray</span></dt><dd><p>Reference beat times, in seconds</p>
</dd>
<dt><strong>estimated_beats</strong><span class="classifier">np.ndarray</span></dt><dd><p>Query beat times, in seconds</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scores</strong><span class="classifier">dict</span></dt><dd><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span> <span class="n">estimated_beats</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="module-mir_eval.chord">
<span id="mir-eval-chord"></span><h3><a class="reference internal" href="#module-mir_eval.chord" title="mir_eval.chord"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.chord</span></code></a><a class="headerlink" href="#module-mir_eval.chord" title="Permalink to this headline">¶</a></h3>
<p>Chord estimation algorithms produce a list of intervals and labels which denote
the chord being played over each timespan.  They are evaluated by comparing the
estimated chord labels to some reference, usually using a mapping to a chord
subalphabet (e.g. minor and major chords only, all triads, etc.).  There is no
single ‘right’ way to compare two sequences of chord labels.  Embracing this
reality, every conventional comparison rule is provided.  Comparisons are made
over the different components of each chord (e.g. G:maj(6)/5): the root (G),
the root-invariant active semitones as determined by the quality
shorthand (maj) and scale degrees (6), and the bass interval (5).
This submodule provides functions both for comparing a sequences of chord
labels according to some chord subalphabet mapping and for using these
comparisons to score a sequence of estimated chords against a reference.</p>
<section id="id2">
<h4>Conventions<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>A sequence of chord labels is represented as a list of strings, where each
label is the chord name based on the syntax of <a class="footnote-reference brackets" href="#harte2010towards" id="id3">1</a>.  Reference
and estimated chord label sequences should be of the same length for comparison
functions.  When converting the chord string into its constituent parts,</p>
<ul class="simple">
<li><p>Pitch class counting starts at C, e.g. C:0, D:2, E:4, F:5, etc.</p></li>
<li><p>Scale degree is represented as a string of the diatonic interval, relative to
the root note, e.g. ‘b6’, ‘#5’, or ‘7’</p></li>
<li><p>Bass intervals are represented as strings</p></li>
<li><p>Chord bitmaps are positional binary vectors indicating active pitch classes
and may be absolute or relative depending on context in the code.</p></li>
</ul>
<p>If no chord is present at a given point in time, it should have the label ‘N’,
which is defined in the variable <code class="docutils literal notranslate"><span class="pre">mir_eval.chord.NO_CHORD</span></code>.</p>
</section>
<section id="id4">
<h4>Metrics<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><a class="reference internal" href="#mir_eval.chord.root" title="mir_eval.chord.root"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.chord.root()</span></code></a>: Only compares the root of the chords.</p></li>
<li><p><a class="reference internal" href="#mir_eval.chord.majmin" title="mir_eval.chord.majmin"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.chord.majmin()</span></code></a>: Only compares major, minor, and “no chord”
labels.</p></li>
<li><p><a class="reference internal" href="#mir_eval.chord.majmin_inv" title="mir_eval.chord.majmin_inv"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.chord.majmin_inv()</span></code></a>: Compares major/minor chords, with
inversions.  The bass note must exist in the triad.</p></li>
<li><p><a class="reference internal" href="#mir_eval.chord.mirex" title="mir_eval.chord.mirex"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.chord.mirex()</span></code></a>: A estimated chord is considered correct if it
shares <em>at least</em> three pitch classes in common.</p></li>
<li><p><a class="reference internal" href="#mir_eval.chord.thirds" title="mir_eval.chord.thirds"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.chord.thirds()</span></code></a>: Chords are compared at the level of major or
minor thirds (root and third), For example, both (‘A:7’, ‘A:maj’) and
(‘A:min’, ‘A:dim’) are equivalent, as the third is major and minor in
quality, respectively.</p></li>
<li><p><a class="reference internal" href="#mir_eval.chord.thirds_inv" title="mir_eval.chord.thirds_inv"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.chord.thirds_inv()</span></code></a>: Same as above, with inversions (bass
relationships).</p></li>
<li><p><a class="reference internal" href="#mir_eval.chord.triads" title="mir_eval.chord.triads"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.chord.triads()</span></code></a>: Chords are considered at the level of triads
(major, minor, augmented, diminished, suspended), meaning that, in addition
to the root, the quality is only considered through #5th scale degree (for
augmented chords). For example, (‘A:7’, ‘A:maj’) are equivalent, while
(‘A:min’, ‘A:dim’) and (‘A:aug’, ‘A:maj’) are not.</p></li>
<li><p><a class="reference internal" href="#mir_eval.chord.triads_inv" title="mir_eval.chord.triads_inv"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.chord.triads_inv()</span></code></a>: Same as above, with inversions (bass
relationships).</p></li>
<li><p><a class="reference internal" href="#mir_eval.chord.tetrads" title="mir_eval.chord.tetrads"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.chord.tetrads()</span></code></a>: Chords are considered at the level of the
entire quality in closed voicing, i.e. spanning only a single octave;
extended chords (9’s, 11’s and 13’s) are rolled into a single octave with any
upper voices included as extensions. For example, (‘A:7’, ‘A:9’) are
equivlent but (‘A:7’, ‘A:maj7’) are not.</p></li>
<li><p><a class="reference internal" href="#mir_eval.chord.tetrads_inv" title="mir_eval.chord.tetrads_inv"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.chord.tetrads_inv()</span></code></a>: Same as above, with inversions (bass
relationships).</p></li>
<li><p><a class="reference internal" href="#mir_eval.chord.sevenths" title="mir_eval.chord.sevenths"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.chord.sevenths()</span></code></a>: Compares according to MIREX “sevenths”
rules; that is, only major, major seventh, seventh, minor, minor seventh and
no chord labels are compared.</p></li>
<li><p><a class="reference internal" href="#mir_eval.chord.sevenths_inv" title="mir_eval.chord.sevenths_inv"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.chord.sevenths_inv()</span></code></a>: Same as above, with inversions (bass
relationships).</p></li>
<li><p><a class="reference internal" href="#mir_eval.chord.overseg" title="mir_eval.chord.overseg"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.chord.overseg()</span></code></a>: Computes the level of over-segmentation
between estimated and reference intervals.</p></li>
<li><p><a class="reference internal" href="#mir_eval.chord.underseg" title="mir_eval.chord.underseg"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.chord.underseg()</span></code></a>: Computes the level of under-segmentation
between estimated and reference intervals.</p></li>
<li><p><a class="reference internal" href="#mir_eval.chord.seg" title="mir_eval.chord.seg"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.chord.seg()</span></code></a>: Computes the minimum of over- and
under-segmentation between estimated and reference intervals.</p></li>
</ul>
</section>
<section id="references">
<h4>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><dl class="footnote brackets">
<dt class="label" id="harte2010towards"><span class="brackets">1</span><span class="fn-backref">(<a href="#id3">1</a>,<a href="#id5">2</a>)</span></dt>
<dd><p>C. Harte. Towards Automatic Extraction of Harmony
Information from Music Signals. PhD thesis, Queen Mary University of
London, August 2010.</p>
</dd>
</dl>
</div></blockquote>
<dl class="py exception">
<dt class="sig sig-object py" id="mir_eval.chord.InvalidChordException">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">InvalidChordException</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">message</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chord_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.InvalidChordException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
<p>Exception class for suspect / invalid chord labels</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.chord.pitch_class_to_semitone">
<span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">pitch_class_to_semitone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pitch_class</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.pitch_class_to_semitone" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a pitch class to semitone.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pitch_class</strong><span class="classifier">str</span></dt><dd><p>Spelling of a given pitch class, e.g. ‘C#’, ‘Gbb’</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>semitone</strong><span class="classifier">int</span></dt><dd><p>Semitone value of the pitch class.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.chord.scale_degree_to_semitone">
<span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">scale_degree_to_semitone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scale_degree</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.scale_degree_to_semitone" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a scale degree to semitone.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>scale degree</strong><span class="classifier">str</span></dt><dd><p>Spelling of a relative scale degree, e.g. ‘b3’, ‘7’, ‘#5’</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>semitone</strong><span class="classifier">int</span></dt><dd><p>Relative semitone of the scale degree, wrapped to a single octave</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>InvalidChordException if <cite>scale_degree</cite> is invalid.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.chord.scale_degree_to_bitmap">
<span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">scale_degree_to_bitmap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scale_degree</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modulo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">12</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.scale_degree_to_bitmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bitmap representation of a scale degree.</p>
<p>Note that values in the bitmap may be negative, indicating that the
semitone is to be removed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>scale_degree</strong><span class="classifier">str</span></dt><dd><p>Spelling of a relative scale degree, e.g. ‘b3’, ‘7’, ‘#5’</p>
</dd>
<dt><strong>modulo</strong><span class="classifier">bool, default=True</span></dt><dd><p>If a scale degree exceeds the length of the bit-vector, modulo the
scale degree back into the bit-vector; otherwise it is discarded.</p>
</dd>
<dt><strong>length</strong><span class="classifier">int, default=12</span></dt><dd><p>Length of the bit-vector to produce</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>bitmap</strong><span class="classifier">np.ndarray, in [-1, 0, 1], len=`length`</span></dt><dd><p>Bitmap representation of this scale degree.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.chord.quality_to_bitmap">
<span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">quality_to_bitmap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quality</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.quality_to_bitmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bitmap for a given quality.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>quality</strong><span class="classifier">str</span></dt><dd><p>Chord quality name.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>bitmap</strong><span class="classifier">np.ndarray</span></dt><dd><p>Bitmap representation of this quality (12-dim).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.chord.reduce_extended_quality">
<span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">reduce_extended_quality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quality</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.reduce_extended_quality" title="Permalink to this definition">¶</a></dt>
<dd><p>Map an extended chord quality to a simpler one, moving upper voices to
a set of scale degree extensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>quality</strong><span class="classifier">str</span></dt><dd><p>Extended chord quality to reduce.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>base_quality</strong><span class="classifier">str</span></dt><dd><p>New chord quality.</p>
</dd>
<dt><strong>extensions</strong><span class="classifier">set</span></dt><dd><p>Scale degrees extensions for the quality.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.chord.validate_chord_label">
<span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">validate_chord_label</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chord_label</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.validate_chord_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Test for well-formedness of a chord label.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>chord</strong><span class="classifier">str</span></dt><dd><p>Chord label to validate.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.chord.split">
<span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chord_label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduce_extended_chords</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.split" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Parse a chord label into its four constituent parts:</dt><dd><ul class="simple">
<li><p>root</p></li>
<li><p>quality shorthand</p></li>
<li><p>scale degrees</p></li>
<li><p>bass</p></li>
</ul>
</dd>
<dt>Note: Chords lacking quality AND interval information are major.</dt><dd><ul class="simple">
<li><p>If a quality is specified, it is returned.</p></li>
<li><p>If an interval is specified WITHOUT a quality, the quality field is
empty.</p></li>
</ul>
</dd>
</dl>
<p>Some examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s1">&#39;C&#39;</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;maj&#39;</span><span class="p">,</span> <span class="p">{},</span> <span class="s1">&#39;1&#39;</span><span class="p">]</span>
<span class="s1">&#39;G#:min(*b3,*5)/5&#39;</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="s1">&#39;G#&#39;</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;*b3&#39;</span><span class="p">,</span> <span class="s1">&#39;*5&#39;</span><span class="p">},</span> <span class="s1">&#39;5&#39;</span><span class="p">]</span>
<span class="s1">&#39;A:(3)/6&#39;</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;3&#39;</span><span class="p">},</span> <span class="s1">&#39;6&#39;</span><span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>chord_label</strong><span class="classifier">str</span></dt><dd><p>A chord label.</p>
</dd>
<dt><strong>reduce_extended_chords</strong><span class="classifier">bool</span></dt><dd><p>Whether to map the upper voicings of extended chords (9’s, 11’s, 13’s)
to semitone extensions. (Default value = False)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>chord_parts</strong><span class="classifier">list</span></dt><dd><p>Split version of the chord label.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.chord.join">
<span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">join</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chord_root</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extensions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Join the parts of a chord into a complete chord label.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>chord_root</strong><span class="classifier">str</span></dt><dd><p>Root pitch class of the chord, e.g. ‘C’, ‘Eb’</p>
</dd>
<dt><strong>quality</strong><span class="classifier">str</span></dt><dd><p>Quality of the chord, e.g. ‘maj’, ‘hdim7’
(Default value = ‘’)</p>
</dd>
<dt><strong>extensions</strong><span class="classifier">list</span></dt><dd><p>Any added or absent scaled degrees for this chord, e.g. [‘4’, ‘*3’]
(Default value = None)</p>
</dd>
<dt><strong>bass</strong><span class="classifier">str</span></dt><dd><p>Scale degree of the bass note, e.g. ‘5’.
(Default value = ‘’)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>chord_label</strong><span class="classifier">str</span></dt><dd><p>A complete chord label.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.chord.encode">
<span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chord_label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduce_extended_chords</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict_bass_intervals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.encode" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate a chord label to numerical representations for evaluation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>chord_label</strong><span class="classifier">str</span></dt><dd><p>Chord label to encode.</p>
</dd>
<dt><strong>reduce_extended_chords</strong><span class="classifier">bool</span></dt><dd><p>Whether to map the upper voicings of extended chords (9’s, 11’s, 13’s)
to semitone extensions.
(Default value = False)</p>
</dd>
<dt><strong>strict_bass_intervals</strong><span class="classifier">bool</span></dt><dd><p>Whether to require that the bass scale degree is present in the chord.
(Default value = False)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>root_number</strong><span class="classifier">int</span></dt><dd><p>Absolute semitone of the chord’s root.</p>
</dd>
<dt><strong>semitone_bitmap</strong><span class="classifier">np.ndarray, dtype=int</span></dt><dd><p>12-dim vector of relative semitones in the chord spelling.</p>
</dd>
<dt><strong>bass_number</strong><span class="classifier">int</span></dt><dd><p>Relative semitone of the chord’s bass note, e.g. 0=root, 7=fifth, etc.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.chord.encode_many">
<span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">encode_many</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chord_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduce_extended_chords</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.encode_many" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate a set of chord labels to numerical representations for sane
evaluation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>chord_labels</strong><span class="classifier">list</span></dt><dd><p>Set of chord labels to encode.</p>
</dd>
<dt><strong>reduce_extended_chords</strong><span class="classifier">bool</span></dt><dd><p>Whether to map the upper voicings of extended chords (9’s, 11’s, 13’s)
to semitone extensions.
(Default value = False)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>root_number</strong><span class="classifier">np.ndarray, dtype=int</span></dt><dd><p>Absolute semitone of the chord’s root.</p>
</dd>
<dt><strong>interval_bitmap</strong><span class="classifier">np.ndarray, dtype=int</span></dt><dd><p>12-dim vector of relative semitones in the given chord quality.</p>
</dd>
<dt><strong>bass_number</strong><span class="classifier">np.ndarray, dtype=int</span></dt><dd><p>Relative semitones of the chord’s bass notes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.chord.rotate_bitmap_to_root">
<span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">rotate_bitmap_to_root</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bitmap</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chord_root</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.rotate_bitmap_to_root" title="Permalink to this definition">¶</a></dt>
<dd><p>Circularly shift a relative bitmap to its asbolute pitch classes.</p>
<p>For clarity, the best explanation is an example. Given ‘G:Maj’, the root
and quality map are as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">root</span><span class="o">=</span><span class="mi">5</span>
<span class="n">quality</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Relative chord shape</span>
</pre></div>
</div>
<p>After rotating to the root, the resulting bitmap becomes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">abs_quality</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># G, B, and D</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bitmap</strong><span class="classifier">np.ndarray, shape=(12,)</span></dt><dd><p>Bitmap of active notes, relative to the given root.</p>
</dd>
<dt><strong>chord_root</strong><span class="classifier">int</span></dt><dd><p>Absolute pitch class number.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>bitmap</strong><span class="classifier">np.ndarray, shape=(12,)</span></dt><dd><p>Absolute bitmap of active pitch classes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.chord.rotate_bitmaps_to_roots">
<span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">rotate_bitmaps_to_roots</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bitmaps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roots</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.rotate_bitmaps_to_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Circularly shift a relative bitmaps to asbolute pitch classes.</p>
<p>See <a class="reference internal" href="#mir_eval.chord.rotate_bitmap_to_root" title="mir_eval.chord.rotate_bitmap_to_root"><code class="xref py py-func docutils literal notranslate"><span class="pre">rotate_bitmap_to_root()</span></code></a> for more information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bitmap</strong><span class="classifier">np.ndarray, shape=(N, 12)</span></dt><dd><p>Bitmap of active notes, relative to the given root.</p>
</dd>
<dt><strong>root</strong><span class="classifier">np.ndarray, shape=(N,)</span></dt><dd><p>Absolute pitch class number.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>bitmap</strong><span class="classifier">np.ndarray, shape=(N, 12)</span></dt><dd><p>Absolute bitmaps of active pitch classes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.chord.validate">
<span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">validate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_labels</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a comparison function look like
valid chord labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_labels</strong><span class="classifier">list, len=n</span></dt><dd><p>Reference chord labels to score against.</p>
</dd>
<dt><strong>estimated_labels</strong><span class="classifier">list, len=n</span></dt><dd><p>Estimated chord labels to score against.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.chord.weighted_accuracy">
<span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">weighted_accuracy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">comparisons</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.weighted_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the weighted accuracy of a list of chord comparisons.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>comparisons</strong><span class="classifier">np.ndarray</span></dt><dd><p>List of chord comparison scores, in [0, 1] or -1</p>
</dd>
<dt><strong>weights</strong><span class="classifier">np.ndarray</span></dt><dd><p>Weights (not necessarily normalized) for each comparison.
This can be a list of interval durations</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>score</strong><span class="classifier">float</span></dt><dd><p>Weighted accuracy</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Here, we&#39;re using the &quot;thirds&quot; function to compare labels</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># but any of the comparison functions would work.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">thirds</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.chord.thirds">
<span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">thirds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_labels</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.thirds" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along root &amp; third relationships.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_labels</strong><span class="classifier">list, len=n</span></dt><dd><p>Reference chord labels to score against.</p>
</dd>
<dt><strong>estimated_labels</strong><span class="classifier">list, len=n</span></dt><dd><p>Estimated chord labels to score against.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>comparison_scores</strong><span class="classifier">np.ndarray, shape=(n,), dtype=float</span></dt><dd><p>Comparison scores, in [0.0, 1.0]</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">thirds</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.chord.thirds_inv">
<span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">thirds_inv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_labels</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.thirds_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Score chords along root, third, &amp; bass relationships.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_labels</strong><span class="classifier">list, len=n</span></dt><dd><p>Reference chord labels to score against.</p>
</dd>
<dt><strong>estimated_labels</strong><span class="classifier">list, len=n</span></dt><dd><p>Estimated chord labels to score against.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scores</strong><span class="classifier">np.ndarray, shape=(n,), dtype=float</span></dt><dd><p>Comparison scores, in [0.0, 1.0]</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">thirds_inv</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.chord.triads">
<span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">triads</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_labels</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.triads" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along triad (root &amp; quality to #5) relationships.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_labels</strong><span class="classifier">list, len=n</span></dt><dd><p>Reference chord labels to score against.</p>
</dd>
<dt><strong>estimated_labels</strong><span class="classifier">list, len=n</span></dt><dd><p>Estimated chord labels to score against.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>comparison_scores</strong><span class="classifier">np.ndarray, shape=(n,), dtype=float</span></dt><dd><p>Comparison scores, in [0.0, 1.0]</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">triads</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.chord.triads_inv">
<span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">triads_inv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_labels</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.triads_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Score chords along triad (root, quality to #5, &amp; bass) relationships.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_labels</strong><span class="classifier">list, len=n</span></dt><dd><p>Reference chord labels to score against.</p>
</dd>
<dt><strong>estimated_labels</strong><span class="classifier">list, len=n</span></dt><dd><p>Estimated chord labels to score against.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scores</strong><span class="classifier">np.ndarray, shape=(n,), dtype=float</span></dt><dd><p>Comparison scores, in [0.0, 1.0]</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">triads_inv</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.chord.tetrads">
<span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">tetrads</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_labels</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.tetrads" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along tetrad (root &amp; full quality) relationships.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_labels</strong><span class="classifier">list, len=n</span></dt><dd><p>Reference chord labels to score against.</p>
</dd>
<dt><strong>estimated_labels</strong><span class="classifier">list, len=n</span></dt><dd><p>Estimated chord labels to score against.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>comparison_scores</strong><span class="classifier">np.ndarray, shape=(n,), dtype=float</span></dt><dd><p>Comparison scores, in [0.0, 1.0]</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">tetrads</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.chord.tetrads_inv">
<span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">tetrads_inv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_labels</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.tetrads_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along tetrad (root, full quality, &amp; bass) relationships.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_labels</strong><span class="classifier">list, len=n</span></dt><dd><p>Reference chord labels to score against.</p>
</dd>
<dt><strong>estimated_labels</strong><span class="classifier">list, len=n</span></dt><dd><p>Estimated chord labels to score against.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>comparison_scores</strong><span class="classifier">np.ndarray, shape=(n,), dtype=float</span></dt><dd><p>Comparison scores, in [0.0, 1.0]</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">tetrads_inv</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.chord.root">
<span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">root</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_labels</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.root" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords according to roots.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_labels</strong><span class="classifier">list, len=n</span></dt><dd><p>Reference chord labels to score against.</p>
</dd>
<dt><strong>estimated_labels</strong><span class="classifier">list, len=n</span></dt><dd><p>Estimated chord labels to score against.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>comparison_scores</strong><span class="classifier">np.ndarray, shape=(n,), dtype=float</span></dt><dd><p>Comparison scores, in [0.0, 1.0], or -1 if the comparison is out of
gamut.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">root</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.chord.mirex">
<span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">mirex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_labels</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.mirex" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along MIREX rules.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_labels</strong><span class="classifier">list, len=n</span></dt><dd><p>Reference chord labels to score against.</p>
</dd>
<dt><strong>estimated_labels</strong><span class="classifier">list, len=n</span></dt><dd><p>Estimated chord labels to score against.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>comparison_scores</strong><span class="classifier">np.ndarray, shape=(n,), dtype=float</span></dt><dd><p>Comparison scores, in [0.0, 1.0]</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">mirex</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.chord.majmin">
<span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">majmin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_labels</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.majmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along major-minor rules. Chords with qualities outside
Major/minor/no-chord are ignored.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_labels</strong><span class="classifier">list, len=n</span></dt><dd><p>Reference chord labels to score against.</p>
</dd>
<dt><strong>estimated_labels</strong><span class="classifier">list, len=n</span></dt><dd><p>Estimated chord labels to score against.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>comparison_scores</strong><span class="classifier">np.ndarray, shape=(n,), dtype=float</span></dt><dd><p>Comparison scores, in [0.0, 1.0], or -1 if the comparison is out of
gamut.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">majmin</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.chord.majmin_inv">
<span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">majmin_inv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_labels</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.majmin_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along major-minor rules, with inversions. Chords with
qualities outside Major/minor/no-chord are ignored, and the bass note must
exist in the triad (bass in [1, 3, 5]).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_labels</strong><span class="classifier">list, len=n</span></dt><dd><p>Reference chord labels to score against.</p>
</dd>
<dt><strong>estimated_labels</strong><span class="classifier">list, len=n</span></dt><dd><p>Estimated chord labels to score against.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>comparison_scores</strong><span class="classifier">np.ndarray, shape=(n,), dtype=float</span></dt><dd><p>Comparison scores, in [0.0, 1.0], or -1 if the comparison is out of
gamut.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">majmin_inv</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.chord.sevenths">
<span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">sevenths</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_labels</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.sevenths" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along MIREX ‘sevenths’ rules. Chords with qualities
outside [maj, maj7, 7, min, min7, N] are ignored.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_labels</strong><span class="classifier">list, len=n</span></dt><dd><p>Reference chord labels to score against.</p>
</dd>
<dt><strong>estimated_labels</strong><span class="classifier">list, len=n</span></dt><dd><p>Estimated chord labels to score against.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>comparison_scores</strong><span class="classifier">np.ndarray, shape=(n,), dtype=float</span></dt><dd><p>Comparison scores, in [0.0, 1.0], or -1 if the comparison is out of
gamut.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">sevenths</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.chord.sevenths_inv">
<span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">sevenths_inv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_labels</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.sevenths_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along MIREX ‘sevenths’ rules. Chords with qualities
outside [maj, maj7, 7, min, min7, N] are ignored.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_labels</strong><span class="classifier">list, len=n</span></dt><dd><p>Reference chord labels to score against.</p>
</dd>
<dt><strong>estimated_labels</strong><span class="classifier">list, len=n</span></dt><dd><p>Estimated chord labels to score against.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>comparison_scores</strong><span class="classifier">np.ndarray, shape=(n,), dtype=float</span></dt><dd><p>Comparison scores, in [0.0, 1.0], or -1 if the comparison is out of
gamut.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">sevenths_inv</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.chord.directional_hamming_distance">
<span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">directional_hamming_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_intervals</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.directional_hamming_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the directional hamming distance between reference and
estimated intervals as defined by <a class="footnote-reference brackets" href="#harte2010towards" id="id5">1</a> and used for MIREX
‘OverSeg’, ‘UnderSeg’ and ‘MeanSeg’ measures.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_intervals</strong><span class="classifier">np.ndarray, shape=(n, 2), dtype=float</span></dt><dd><p>Reference chord intervals to score against.</p>
</dd>
<dt><strong>estimated_intervals</strong><span class="classifier">np.ndarray, shape=(m, 2), dtype=float</span></dt><dd><p>Estimated chord intervals to score against.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>directional hamming distance</strong><span class="classifier">float</span></dt><dd><p>directional hamming distance between reference intervals and
estimated intervals.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">overseg</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">directional_hamming_distance</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">underseg</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">directional_hamming_distance</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seg</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">overseg</span><span class="p">,</span> <span class="n">underseg</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.chord.overseg">
<span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">overseg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_intervals</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.overseg" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the MIREX ‘OverSeg’ score.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_intervals</strong><span class="classifier">np.ndarray, shape=(n, 2), dtype=float</span></dt><dd><p>Reference chord intervals to score against.</p>
</dd>
<dt><strong>estimated_intervals</strong><span class="classifier">np.ndarray, shape=(m, 2), dtype=float</span></dt><dd><p>Estimated chord intervals to score against.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oversegmentation score</strong><span class="classifier">float</span></dt><dd><p>Comparison score, in [0.0, 1.0], where 1.0 means no oversegmentation.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">overseg</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.chord.underseg">
<span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">underseg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_intervals</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.underseg" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the MIREX ‘UnderSeg’ score.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_intervals</strong><span class="classifier">np.ndarray, shape=(n, 2), dtype=float</span></dt><dd><p>Reference chord intervals to score against.</p>
</dd>
<dt><strong>estimated_intervals</strong><span class="classifier">np.ndarray, shape=(m, 2), dtype=float</span></dt><dd><p>Estimated chord intervals to score against.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>undersegmentation score</strong><span class="classifier">float</span></dt><dd><p>Comparison score, in [0.0, 1.0], where 1.0 means no undersegmentation.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">underseg</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.chord.seg">
<span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">seg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_intervals</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.seg" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the MIREX ‘MeanSeg’ score.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_intervals</strong><span class="classifier">np.ndarray, shape=(n, 2), dtype=float</span></dt><dd><p>Reference chord intervals to score against.</p>
</dd>
<dt><strong>estimated_intervals</strong><span class="classifier">np.ndarray, shape=(m, 2), dtype=float</span></dt><dd><p>Estimated chord intervals to score against.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>segmentation score</strong><span class="classifier">float</span></dt><dd><p>Comparison score, in [0.0, 1.0], where 1.0 means perfect segmentation.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">seg</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.chord.merge_chord_intervals">
<span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">merge_chord_intervals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.merge_chord_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge consecutive chord intervals if they represent the same chord.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>intervals</strong><span class="classifier">np.ndarray, shape=(n, 2), dtype=float</span></dt><dd><p>Chord intervals to be merged, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>labels</strong><span class="classifier">list, shape=(n,)</span></dt><dd><p>Chord labels to be merged, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>merged_ivs</strong><span class="classifier">np.ndarray, shape=(k, 2), dtype=float</span></dt><dd><p>Merged chord intervals, k &lt;= n</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.chord.evaluate">
<span class="sig-prename descclassname"><span class="pre">mir_eval.chord.</span></span><span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_labels</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes weighted accuracy for all comparison functions for the given
reference and estimated annotations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ref_intervals</strong><span class="classifier">np.ndarray, shape=(n, 2)</span></dt><dd><p>Reference chord intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>ref_labels</strong><span class="classifier">list, shape=(n,)</span></dt><dd><p>reference chord labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>est_intervals</strong><span class="classifier">np.ndarray, shape=(m, 2)</span></dt><dd><p>estimated chord intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>est_labels</strong><span class="classifier">list, shape=(m,)</span></dt><dd><p>estimated chord labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scores</strong><span class="classifier">dict</span></dt><dd><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                 <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="module-mir_eval.melody">
<span id="mir-eval-melody"></span><h3><a class="reference internal" href="#module-mir_eval.melody" title="mir_eval.melody"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.melody</span></code></a><a class="headerlink" href="#module-mir_eval.melody" title="Permalink to this headline">¶</a></h3>
<p>Melody extraction algorithms aim to produce a sequence of frequency values
corresponding to the pitch of the dominant melody from a musical
recording.  For evaluation, an estimated pitch series is evaluated against a
reference based on whether the voicing (melody present or not) and the pitch
is correct (within some tolerance).</p>
<dl class="simple">
<dt>For a detailed explanation of the measures please refer to:</dt><dd><p>J. Salamon, E. Gomez, D. P. W. Ellis and G. Richard, “Melody Extraction
from Polyphonic Music Signals: Approaches, Applications and Challenges”,
IEEE Signal Processing Magazine, 31(2):118-134, Mar. 2014.</p>
</dd>
<dt>and:</dt><dd><p>G. E. Poliner, D. P. W. Ellis, A. F. Ehmann, E. Gomez, S.
Streich, and B. Ong. “Melody transcription from music audio:
Approaches and evaluation”, IEEE Transactions on Audio, Speech, and
Language Processing, 15(4):1247-1256, 2007.</p>
</dd>
</dl>
<p>For an explanation of the generalized measures (using non-binary voicings),
please refer to:</p>
<blockquote>
<div><p>R. Bittner and J. Bosch, “Generalized Metrics for Single-F0 Estimation
Evaluation”, International Society for Music Information Retrieval
Conference (ISMIR), 2019.</p>
</div></blockquote>
<section id="id6">
<h4>Conventions<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p>Melody annotations are assumed to be given in the format of a 1d array of
frequency values which are accompanied by a 1d array of times denoting when
each frequency value occurs.  In a reference melody time series, a frequency
value of 0 denotes “unvoiced”.  In a estimated melody time series, unvoiced
frames can be indicated either by 0 Hz or by a negative Hz value - negative
values represent the algorithm’s pitch estimate for frames it has determined as
unvoiced, in case they are in fact voiced.</p>
<p>Metrics are computed using a sequence of reference and estimated pitches in
cents and voicing arrays, both of which are sampled to the same
timebase.  The function <a class="reference internal" href="#mir_eval.melody.to_cent_voicing" title="mir_eval.melody.to_cent_voicing"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.melody.to_cent_voicing()</span></code></a> can be used to
convert a sequence of estimated and reference times and frequency values in Hz
to voicing arrays and frequency arrays in the format required by the
metric functions.  By default, the convention is to resample the estimated
melody time series to the reference melody time series’ timebase.</p>
</section>
<section id="id7">
<h4>Metrics<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><a class="reference internal" href="#mir_eval.melody.voicing_measures" title="mir_eval.melody.voicing_measures"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.melody.voicing_measures()</span></code></a>: Voicing measures, including the
recall rate (proportion of frames labeled as melody frames in the reference
that are estimated as melody frames) and the false alarm
rate (proportion of frames labeled as non-melody in the reference that are
mistakenly estimated as melody frames)</p></li>
<li><p><a class="reference internal" href="#mir_eval.melody.raw_pitch_accuracy" title="mir_eval.melody.raw_pitch_accuracy"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.melody.raw_pitch_accuracy()</span></code></a>: Raw Pitch Accuracy, which
computes the proportion of melody frames in the reference for which the
frequency is considered correct (i.e. within half a semitone of the reference
frequency)</p></li>
<li><p><a class="reference internal" href="#mir_eval.melody.raw_chroma_accuracy" title="mir_eval.melody.raw_chroma_accuracy"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.melody.raw_chroma_accuracy()</span></code></a>: Raw Chroma Accuracy, where the
estimated and reference frequency sequences are mapped onto a single octave
before computing the raw pitch accuracy</p></li>
<li><p><a class="reference internal" href="#mir_eval.melody.overall_accuracy" title="mir_eval.melody.overall_accuracy"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.melody.overall_accuracy()</span></code></a>: Overall Accuracy, which computes
the proportion of all frames correctly estimated by the algorithm, including
whether non-melody frames where labeled by the algorithm as non-melody</p></li>
</ul>
<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.melody.validate_voicing">
<span class="sig-prename descclassname"><span class="pre">mir_eval.melody.</span></span><span class="sig-name descname"><span class="pre">validate_voicing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_voicing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_voicing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.validate_voicing" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that voicing inputs to a metric are in the correct format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ref_voicing</strong><span class="classifier">np.ndarray</span></dt><dd><p>Reference voicing array</p>
</dd>
<dt><strong>est_voicing</strong><span class="classifier">np.ndarray</span></dt><dd><p>Estimated voicing array</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.melody.validate">
<span class="sig-prename descclassname"><span class="pre">mir_eval.melody.</span></span><span class="sig-name descname"><span class="pre">validate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_voicing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_cent</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_voicing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_cent</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that voicing and frequency arrays are well-formed.  To be used in
conjunction with <a class="reference internal" href="#mir_eval.melody.validate_voicing" title="mir_eval.melody.validate_voicing"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.melody.validate_voicing()</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ref_voicing</strong><span class="classifier">np.ndarray</span></dt><dd><p>Reference voicing array</p>
</dd>
<dt><strong>ref_cent</strong><span class="classifier">np.ndarray</span></dt><dd><p>Reference pitch sequence in cents</p>
</dd>
<dt><strong>est_voicing</strong><span class="classifier">np.ndarray</span></dt><dd><p>Estimated voicing array</p>
</dd>
<dt><strong>est_cent</strong><span class="classifier">np.ndarray</span></dt><dd><p>Estimate pitch sequence in cents</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.melody.hz2cents">
<span class="sig-prename descclassname"><span class="pre">mir_eval.melody.</span></span><span class="sig-name descname"><span class="pre">hz2cents</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">freq_hz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_frequency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.hz2cents" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an array of frequency values in Hz to cents.
0 values are left in place.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>freq_hz</strong><span class="classifier">np.ndarray</span></dt><dd><p>Array of frequencies in Hz.</p>
</dd>
<dt><strong>base_frequency</strong><span class="classifier">float</span></dt><dd><p>Base frequency for conversion.
(Default value = 10.0)</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>freq_cent</strong><span class="classifier">np.ndarray</span></dt><dd><p>Array of frequencies in cents, relative to base_frequency</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.melody.freq_to_voicing">
<span class="sig-prename descclassname"><span class="pre">mir_eval.melody.</span></span><span class="sig-name descname"><span class="pre">freq_to_voicing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frequencies</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">voicing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.freq_to_voicing" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from an array of frequency values to frequency array +
voice/unvoiced array</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>frequencies</strong><span class="classifier">np.ndarray</span></dt><dd><p>Array of frequencies.  A frequency &lt;= 0 indicates “unvoiced”.</p>
</dd>
<dt><strong>voicing</strong><span class="classifier">np.ndarray</span></dt><dd><p>Array of voicing values.
(Default value = None)
Default None, which means the voicing is inferred from <cite>frequencies</cite>:</p>
<blockquote>
<div><p>frames with frequency &lt;= 0.0 are considered “unvoiced”
frames with frequency &gt; 0.0 are considered “voiced”</p>
</div></blockquote>
<p>If specified, <cite>voicing</cite> is used as the voicing array, but
frequencies with value 0 are forced to have 0 voicing.</p>
<blockquote>
<div><p>Voicing inferred by negative frequency values is ignored.</p>
</div></blockquote>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>frequencies</strong><span class="classifier">np.ndarray</span></dt><dd><p>Array of frequencies, all &gt;= 0.</p>
</dd>
<dt><strong>voiced</strong><span class="classifier">np.ndarray</span></dt><dd><p>Array of voicings between 0 and 1, same length as frequencies,
which indicates voiced or unvoiced</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.melody.constant_hop_timebase">
<span class="sig-prename descclassname"><span class="pre">mir_eval.melody.</span></span><span class="sig-name descname"><span class="pre">constant_hop_timebase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hop</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_time</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.constant_hop_timebase" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a time series from 0 to <code class="docutils literal notranslate"><span class="pre">end_time</span></code> with times spaced <code class="docutils literal notranslate"><span class="pre">hop</span></code>
apart</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>hop</strong><span class="classifier">float</span></dt><dd><p>Spacing of samples in the time series</p>
</dd>
<dt><strong>end_time</strong><span class="classifier">float</span></dt><dd><p>Time series will span <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">end_time]</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>times</strong><span class="classifier">np.ndarray</span></dt><dd><p>Generated timebase</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.melody.resample_melody_series">
<span class="sig-prename descclassname"><span class="pre">mir_eval.melody.</span></span><span class="sig-name descname"><span class="pre">resample_melody_series</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequencies</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">voicing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">times_new</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.resample_melody_series" title="Permalink to this definition">¶</a></dt>
<dd><p>Resamples frequency and voicing time series to a new timescale. Maintains
any zero (“unvoiced”) values in frequencies.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">times_new</span></code> are equivalent, no resampling will be
performed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>times</strong><span class="classifier">np.ndarray</span></dt><dd><p>Times of each frequency value</p>
</dd>
<dt><strong>frequencies</strong><span class="classifier">np.ndarray</span></dt><dd><p>Array of frequency values, &gt;= 0</p>
</dd>
<dt><strong>voicing</strong><span class="classifier">np.ndarray</span></dt><dd><p>Array which indicates voiced or unvoiced. This array may be binary
or have continuous values between 0 and 1.</p>
</dd>
<dt><strong>times_new</strong><span class="classifier">np.ndarray</span></dt><dd><p>Times to resample frequency and voicing sequences to</p>
</dd>
<dt><strong>kind</strong><span class="classifier">str</span></dt><dd><p>kind parameter to pass to scipy.interpolate.interp1d.
(Default value = ‘linear’)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>frequencies_resampled</strong><span class="classifier">np.ndarray</span></dt><dd><p>Frequency array resampled to new timebase</p>
</dd>
<dt><strong>voicing_resampled</strong><span class="classifier">np.ndarray</span></dt><dd><p>Voicing array resampled to new timebase</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.melody.to_cent_voicing">
<span class="sig-prename descclassname"><span class="pre">mir_eval.melody.</span></span><span class="sig-name descname"><span class="pre">to_cent_voicing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_voicing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_reward</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_frequency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.to_cent_voicing" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts reference and estimated time/frequency (Hz) annotations to sampled
frequency (cent)/voicing arrays.</p>
<p>A zero frequency indicates “unvoiced”.</p>
<dl class="simple">
<dt>If est_voicing is not provided, a negative frequency indicates:</dt><dd><dl class="simple">
<dt>“Predicted as unvoiced, but if it’s voiced,</dt><dd><p>this is the frequency estimate”.</p>
</dd>
</dl>
</dd>
<dt>If it is provided, negative frequency values are ignored, and the voicing</dt><dd><p>from est_voicing is directly used.</p>
</dd>
</dl>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>ref_time</strong><span class="classifier">np.ndarray</span></dt><dd><p>Time of each reference frequency value</p>
</dd>
<dt><strong>ref_freq</strong><span class="classifier">np.ndarray</span></dt><dd><p>Array of reference frequency values</p>
</dd>
<dt><strong>est_time</strong><span class="classifier">np.ndarray</span></dt><dd><p>Time of each estimated frequency value</p>
</dd>
<dt><strong>est_freq</strong><span class="classifier">np.ndarray</span></dt><dd><p>Array of estimated frequency values</p>
</dd>
<dt><strong>est_voicing</strong><span class="classifier">np.ndarray</span></dt><dd><p>Estimate voicing confidence.
Default None, which means the voicing is inferred from est_freq:</p>
<blockquote>
<div><p>frames with frequency &lt;= 0.0 are considered “unvoiced”
frames with frequency &gt; 0.0 are considered “voiced”</p>
</div></blockquote>
</dd>
<dt><strong>ref_reward</strong><span class="classifier">np.ndarray</span></dt><dd><p>Reference voicing reward.
Default None, which means all frames are weighted equally.</p>
</dd>
<dt><strong>base_frequency</strong><span class="classifier">float</span></dt><dd><p>Base frequency in Hz for conversion to cents
(Default value = 10.)</p>
</dd>
<dt><strong>hop</strong><span class="classifier">float</span></dt><dd><p>Hop size, in seconds, to resample,
default None which means use ref_time</p>
</dd>
<dt><strong>kind</strong><span class="classifier">str</span></dt><dd><p>kind parameter to pass to scipy.interpolate.interp1d.
(Default value = ‘linear’)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ref_voicing</strong><span class="classifier">np.ndarray</span></dt><dd><p>Resampled reference voicing array</p>
</dd>
<dt><strong>ref_cent</strong><span class="classifier">np.ndarray</span></dt><dd><p>Resampled reference frequency (cent) array</p>
</dd>
<dt><strong>est_voicing</strong><span class="classifier">np.ndarray</span></dt><dd><p>Resampled estimated voicing array</p>
</dd>
<dt><strong>est_cent</strong><span class="classifier">np.ndarray</span></dt><dd><p>Resampled estimated frequency (cent) array</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.melody.voicing_recall">
<span class="sig-prename descclassname"><span class="pre">mir_eval.melody.</span></span><span class="sig-name descname"><span class="pre">voicing_recall</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_voicing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_voicing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.voicing_recall" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the voicing recall given two voicing
indicator sequences, one as reference (truth) and the other as the estimate
(prediction).  The sequences must be of the same length.
Examples
——–
&gt;&gt;&gt; ref_time, ref_freq = mir_eval.io.load_time_series(‘ref.txt’)
&gt;&gt;&gt; est_time, est_freq = mir_eval.io.load_time_series(‘est.txt’)
&gt;&gt;&gt; (ref_v, ref_c,
…  est_v, est_c) = mir_eval.melody.to_cent_voicing(ref_time,
…                                                  ref_freq,
…                                                  est_time,
…                                                  est_freq)
&gt;&gt;&gt; recall = mir_eval.melody.voicing_recall(ref_v, est_v)
Parameters
———-
ref_voicing : np.ndarray</p>
<blockquote>
<div><p>Reference boolean voicing array</p>
</div></blockquote>
<dl class="simple">
<dt>est_voicing<span class="classifier">np.ndarray</span></dt><dd><p>Estimated boolean voicing array</p>
</dd>
</dl>
<dl class="simple">
<dt>vx_recall<span class="classifier">float</span></dt><dd><p>Voicing recall rate, the fraction of voiced frames in ref
indicated as voiced in est</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.melody.voicing_false_alarm">
<span class="sig-prename descclassname"><span class="pre">mir_eval.melody.</span></span><span class="sig-name descname"><span class="pre">voicing_false_alarm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_voicing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_voicing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.voicing_false_alarm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the voicing false alarm rates given two voicing
indicator sequences, one as reference (truth) and the other as the estimate
(prediction).  The sequences must be of the same length.
Examples
——–
&gt;&gt;&gt; ref_time, ref_freq = mir_eval.io.load_time_series(‘ref.txt’)
&gt;&gt;&gt; est_time, est_freq = mir_eval.io.load_time_series(‘est.txt’)
&gt;&gt;&gt; (ref_v, ref_c,
…  est_v, est_c) = mir_eval.melody.to_cent_voicing(ref_time,
…                                                  ref_freq,
…                                                  est_time,
…                                                  est_freq)
&gt;&gt;&gt; false_alarm = mir_eval.melody.voicing_false_alarm(ref_v, est_v)
Parameters
———-
ref_voicing : np.ndarray</p>
<blockquote>
<div><p>Reference boolean voicing array</p>
</div></blockquote>
<dl class="simple">
<dt>est_voicing<span class="classifier">np.ndarray</span></dt><dd><p>Estimated boolean voicing array</p>
</dd>
</dl>
<dl class="simple">
<dt>vx_false_alarm<span class="classifier">float</span></dt><dd><p>Voicing false alarm rate, the fraction of unvoiced frames in ref
indicated as voiced in est</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.melody.voicing_measures">
<span class="sig-prename descclassname"><span class="pre">mir_eval.melody.</span></span><span class="sig-name descname"><span class="pre">voicing_measures</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_voicing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_voicing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.voicing_measures" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the voicing recall and false alarm rates given two voicing
indicator sequences, one as reference (truth) and the other as the estimate
(prediction).  The sequences must be of the same length.
Examples
——–
&gt;&gt;&gt; ref_time, ref_freq = mir_eval.io.load_time_series(‘ref.txt’)
&gt;&gt;&gt; est_time, est_freq = mir_eval.io.load_time_series(‘est.txt’)
&gt;&gt;&gt; (ref_v, ref_c,
…  est_v, est_c) = mir_eval.melody.to_cent_voicing(ref_time,
…                                                  ref_freq,
…                                                  est_time,
…                                                  est_freq)
&gt;&gt;&gt; recall, false_alarm = mir_eval.melody.voicing_measures(ref_v,
…                                                        est_v)
Parameters
———-
ref_voicing : np.ndarray</p>
<blockquote>
<div><p>Reference boolean voicing array</p>
</div></blockquote>
<dl class="simple">
<dt>est_voicing<span class="classifier">np.ndarray</span></dt><dd><p>Estimated boolean voicing array</p>
</dd>
</dl>
<dl class="simple">
<dt>vx_recall<span class="classifier">float</span></dt><dd><p>Voicing recall rate, the fraction of voiced frames in ref
indicated as voiced in est</p>
</dd>
<dt>vx_false_alarm<span class="classifier">float</span></dt><dd><p>Voicing false alarm rate, the fraction of unvoiced frames in ref
indicated as voiced in est</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.melody.raw_pitch_accuracy">
<span class="sig-prename descclassname"><span class="pre">mir_eval.melody.</span></span><span class="sig-name descname"><span class="pre">raw_pitch_accuracy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_voicing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_cent</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_voicing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_cent</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cent_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.raw_pitch_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the raw pitch accuracy given two pitch (frequency) sequences in
cents and matching voicing indicator sequences. The first pitch and voicing
arrays are treated as the reference (truth), and the second two as the
estimate (prediction).  All 4 sequences must be of the same length.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ref_voicing</strong><span class="classifier">np.ndarray</span></dt><dd><p>Reference voicing array. When this array is non-binary, it is treated
as a ‘reference reward’, as in (Bittner &amp; Bosch, 2019)</p>
</dd>
<dt><strong>ref_cent</strong><span class="classifier">np.ndarray</span></dt><dd><p>Reference pitch sequence in cents</p>
</dd>
<dt><strong>est_voicing</strong><span class="classifier">np.ndarray</span></dt><dd><p>Estimated voicing array</p>
</dd>
<dt><strong>est_cent</strong><span class="classifier">np.ndarray</span></dt><dd><p>Estimate pitch sequence in cents</p>
</dd>
<dt><strong>cent_tolerance</strong><span class="classifier">float</span></dt><dd><p>Maximum absolute deviation in cents for a frequency value to be
considered correct
(Default value = 50)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>raw_pitch</strong><span class="classifier">float</span></dt><dd><p>Raw pitch accuracy, the fraction of voiced frames in ref_cent for
which est_cent provides a correct frequency values
(within cent_tolerance cents).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_time</span><span class="p">,</span> <span class="n">ref_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s1">&#39;ref.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_time</span><span class="p">,</span> <span class="n">est_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s1">&#39;est.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_v</span><span class="p">,</span> <span class="n">ref_c</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_v</span><span class="p">,</span> <span class="n">est_c</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">melody</span><span class="o">.</span><span class="n">to_cent_voicing</span><span class="p">(</span><span class="n">ref_time</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">ref_freq</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">est_time</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">est_freq</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">raw_pitch</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">melody</span><span class="o">.</span><span class="n">raw_pitch_accuracy</span><span class="p">(</span><span class="n">ref_v</span><span class="p">,</span> <span class="n">ref_c</span><span class="p">,</span>
<span class="gp">... </span>                                               <span class="n">est_v</span><span class="p">,</span> <span class="n">est_c</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.melody.raw_chroma_accuracy">
<span class="sig-prename descclassname"><span class="pre">mir_eval.melody.</span></span><span class="sig-name descname"><span class="pre">raw_chroma_accuracy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_voicing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_cent</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_voicing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_cent</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cent_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.raw_chroma_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the raw chroma accuracy given two pitch (frequency) sequences
in cents and matching voicing indicator sequences. The first pitch and
voicing arrays are treated as the reference (truth), and the second two as
the estimate (prediction).  All 4 sequences must be of the same length.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ref_voicing</strong><span class="classifier">np.ndarray</span></dt><dd><p>Reference voicing array. When this array is non-binary, it is treated
as a ‘reference reward’, as in (Bittner &amp; Bosch, 2019)</p>
</dd>
<dt><strong>ref_cent</strong><span class="classifier">np.ndarray</span></dt><dd><p>Reference pitch sequence in cents</p>
</dd>
<dt><strong>est_voicing</strong><span class="classifier">np.ndarray</span></dt><dd><p>Estimated voicing array</p>
</dd>
<dt><strong>est_cent</strong><span class="classifier">np.ndarray</span></dt><dd><p>Estimate pitch sequence in cents</p>
</dd>
<dt><strong>cent_tolerance</strong><span class="classifier">float</span></dt><dd><p>Maximum absolute deviation in cents for a frequency value to be
considered correct
(Default value = 50)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>raw_chroma</strong><span class="classifier">float</span></dt><dd><p>Raw chroma accuracy, the fraction of voiced frames in ref_cent for
which est_cent provides a correct frequency values (within
cent_tolerance cents), ignoring octave errors</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_time</span><span class="p">,</span> <span class="n">ref_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s1">&#39;ref.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_time</span><span class="p">,</span> <span class="n">est_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s1">&#39;est.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_v</span><span class="p">,</span> <span class="n">ref_c</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_v</span><span class="p">,</span> <span class="n">est_c</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">melody</span><span class="o">.</span><span class="n">to_cent_voicing</span><span class="p">(</span><span class="n">ref_time</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">ref_freq</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">est_time</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">est_freq</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">raw_chroma</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">melody</span><span class="o">.</span><span class="n">raw_chroma_accuracy</span><span class="p">(</span><span class="n">ref_v</span><span class="p">,</span> <span class="n">ref_c</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">est_v</span><span class="p">,</span> <span class="n">est_c</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.melody.overall_accuracy">
<span class="sig-prename descclassname"><span class="pre">mir_eval.melody.</span></span><span class="sig-name descname"><span class="pre">overall_accuracy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_voicing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_cent</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_voicing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_cent</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cent_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.overall_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the overall accuracy given two pitch (frequency) sequences
in cents and matching voicing indicator sequences. The first pitch and
voicing arrays are treated as the reference (truth), and the second two
as the estimate (prediction).  All 4 sequences must be of the same length.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ref_voicing</strong><span class="classifier">np.ndarray</span></dt><dd><p>Reference voicing array. When this array is non-binary, it is treated
as a ‘reference reward’, as in (Bittner &amp; Bosch, 2019)</p>
</dd>
<dt><strong>ref_cent</strong><span class="classifier">np.ndarray</span></dt><dd><p>Reference pitch sequence in cents</p>
</dd>
<dt><strong>est_voicing</strong><span class="classifier">np.ndarray</span></dt><dd><p>Estimated voicing array</p>
</dd>
<dt><strong>est_cent</strong><span class="classifier">np.ndarray</span></dt><dd><p>Estimate pitch sequence in cents</p>
</dd>
<dt><strong>cent_tolerance</strong><span class="classifier">float</span></dt><dd><p>Maximum absolute deviation in cents for a frequency value to be
considered correct
(Default value = 50)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>overall_accuracy</strong><span class="classifier">float</span></dt><dd><p>Overall accuracy, the total fraction of correctly estimates frames,
where provides a correct frequency values (within cent_tolerance).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_time</span><span class="p">,</span> <span class="n">ref_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s1">&#39;ref.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_time</span><span class="p">,</span> <span class="n">est_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s1">&#39;est.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_v</span><span class="p">,</span> <span class="n">ref_c</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_v</span><span class="p">,</span> <span class="n">est_c</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">melody</span><span class="o">.</span><span class="n">to_cent_voicing</span><span class="p">(</span><span class="n">ref_time</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">ref_freq</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">est_time</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">est_freq</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">overall_accuracy</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">melody</span><span class="o">.</span><span class="n">overall_accuracy</span><span class="p">(</span><span class="n">ref_v</span><span class="p">,</span> <span class="n">ref_c</span><span class="p">,</span>
<span class="gp">... </span>                                                    <span class="n">est_v</span><span class="p">,</span> <span class="n">est_c</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.melody.evaluate">
<span class="sig-prename descclassname"><span class="pre">mir_eval.melody.</span></span><span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_voicing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_reward</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate two melody (predominant f0) transcriptions, where the first is
treated as the reference (ground truth) and the second as the estimate to
be evaluated (prediction).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>ref_time</strong><span class="classifier">np.ndarray</span></dt><dd><p>Time of each reference frequency value</p>
</dd>
<dt><strong>ref_freq</strong><span class="classifier">np.ndarray</span></dt><dd><p>Array of reference frequency values</p>
</dd>
<dt><strong>est_time</strong><span class="classifier">np.ndarray</span></dt><dd><p>Time of each estimated frequency value</p>
</dd>
<dt><strong>est_freq</strong><span class="classifier">np.ndarray</span></dt><dd><p>Array of estimated frequency values</p>
</dd>
<dt><strong>est_voicing</strong><span class="classifier">np.ndarray</span></dt><dd><p>Estimate voicing confidence.
Default None, which means the voicing is inferred from est_freq:</p>
<blockquote>
<div><p>frames with frequency &lt;= 0.0 are considered “unvoiced”
frames with frequency &gt; 0.0 are considered “voiced”</p>
</div></blockquote>
</dd>
<dt><strong>ref_reward</strong><span class="classifier">np.ndarray</span></dt><dd><p>Reference pitch estimation reward.
Default None, which means all frames are weighted equally.</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scores</strong><span class="classifier">dict</span></dt><dd><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id8"><span class="brackets">2</span></dt>
<dd><p>J. Salamon, E. Gomez, D. P. W. Ellis and G. Richard, “Melody
Extraction from Polyphonic Music Signals: Approaches, Applications
and Challenges”, IEEE Signal Processing Magazine, 31(2):118-134,
Mar. 2014.</p>
</dd>
<dt class="label" id="id9"><span class="brackets">3</span></dt>
<dd><p>G. E. Poliner, D. P. W. Ellis, A. F. Ehmann, E. Gomez, S.
Streich, and B. Ong. “Melody transcription from music audio:
Approaches and evaluation”, IEEE Transactions on Audio, Speech, and
Language Processing, 15(4):1247-1256, 2007.</p>
</dd>
<dt class="label" id="id10"><span class="brackets">4</span></dt>
<dd><p>R. Bittner and J. Bosch, “Generalized Metrics for Single-F0
Estimation Evaluation”, International Society for Music Information
Retrieval Conference (ISMIR), 2019.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_time</span><span class="p">,</span> <span class="n">ref_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s1">&#39;ref.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_time</span><span class="p">,</span> <span class="n">est_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s1">&#39;est.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">melody</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ref_time</span><span class="p">,</span> <span class="n">ref_freq</span><span class="p">,</span>
<span class="gp">... </span>                                  <span class="n">est_time</span><span class="p">,</span> <span class="n">est_freq</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="module-mir_eval.multipitch">
<span id="mir-eval-multipitch"></span><h3><a class="reference internal" href="#module-mir_eval.multipitch" title="mir_eval.multipitch"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.multipitch</span></code></a><a class="headerlink" href="#module-mir_eval.multipitch" title="Permalink to this headline">¶</a></h3>
<p>The goal of multiple f0 (multipitch) estimation and tracking is to identify
all of the active fundamental frequencies in each time frame in a complex music
signal.</p>
<section id="id11">
<h4>Conventions<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p>Multipitch estimates are represented by a timebase and a corresponding list
of arrays of frequency estimates. Frequency estimates may have any number of
frequency values, including 0 (represented by an empty array). Time values are
in units of seconds and frequency estimates are in units of Hz.</p>
<p>The timebase of the estimate time series should ideally match the timebase of
the reference time series, but if this is not the case, the estimate time
series is resampled using a nearest neighbor interpolation to match the
estimate. Time values in the estimate time series that are outside of the range
of the reference time series are given null (empty array) frequencies.</p>
<p>By default, a frequency is “correct” if it is within 0.5 semitones of a
reference frequency. Frequency values are compared by first mapping them to
log-2 semitone space, where the distance between semitones is constant.
Chroma-wrapped frequency values are computed by taking the log-2 frequency
values modulo 12 to map them down to a single octave. A chroma-wrapped
frequency estimate is correct if it’s single-octave value is within 0.5
semitones of the single-octave reference frequency.</p>
<p>The metrics are based on those described in
<a class="footnote-reference brackets" href="#poliner2007" id="id12">5</a> and <a class="footnote-reference brackets" href="#bay2009" id="id13">6</a>.</p>
</section>
<section id="id14">
<h4>Metrics<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><a class="reference internal" href="#mir_eval.multipitch.metrics" title="mir_eval.multipitch.metrics"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.multipitch.metrics()</span></code></a>: Precision, Recall, Accuracy,
Substitution, Miss, False Alarm, and Total Error scores based both on raw
frequency values and values mapped to a single octave (chroma).</p></li>
</ul>
</section>
<section id="id15">
<h4>References<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h4>
<dl class="footnote brackets">
<dt class="label" id="poliner2007"><span class="brackets"><a class="fn-backref" href="#id12">5</a></span></dt>
<dd><p>G. E. Poliner, and D. P. W. Ellis, “A Discriminative
Model for Polyphonic Piano Transription”, EURASIP Journal on Advances in
Signal Processing, 2007(1):154-163, Jan. 2007.</p>
</dd>
<dt class="label" id="bay2009"><span class="brackets"><a class="fn-backref" href="#id13">6</a></span></dt>
<dd><p>Bay, M., Ehmann, A. F., &amp; Downie, J. S. (2009). Evaluation of
Multiple-F0 Estimation and Tracking Systems. In ISMIR (pp. 315-320).</p>
</dd>
</dl>
<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.multipitch.validate">
<span class="sig-prename descclassname"><span class="pre">mir_eval.multipitch.</span></span><span class="sig-name descname"><span class="pre">validate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_freqs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_freqs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.multipitch.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the time and frequency inputs are well-formed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ref_time</strong><span class="classifier">np.ndarray</span></dt><dd><p>reference time stamps in seconds</p>
</dd>
<dt><strong>ref_freqs</strong><span class="classifier">list of np.ndarray</span></dt><dd><p>reference frequencies in Hz</p>
</dd>
<dt><strong>est_time</strong><span class="classifier">np.ndarray</span></dt><dd><p>estimate time stamps in seconds</p>
</dd>
<dt><strong>est_freqs</strong><span class="classifier">list of np.ndarray</span></dt><dd><p>estimated frequencies in Hz</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.multipitch.resample_multipitch">
<span class="sig-prename descclassname"><span class="pre">mir_eval.multipitch.</span></span><span class="sig-name descname"><span class="pre">resample_multipitch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequencies</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_times</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.multipitch.resample_multipitch" title="Permalink to this definition">¶</a></dt>
<dd><p>Resamples multipitch time series to a new timescale. Values in
<code class="docutils literal notranslate"><span class="pre">target_times</span></code> outside the range of <code class="docutils literal notranslate"><span class="pre">times</span></code> return no pitch estimate.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>times</strong><span class="classifier">np.ndarray</span></dt><dd><p>Array of time stamps</p>
</dd>
<dt><strong>frequencies</strong><span class="classifier">list of np.ndarray</span></dt><dd><p>List of np.ndarrays of frequency values</p>
</dd>
<dt><strong>target_times</strong><span class="classifier">np.ndarray</span></dt><dd><p>Array of target time stamps</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>frequencies_resampled</strong><span class="classifier">list of numpy arrays</span></dt><dd><p>Frequency list of lists resampled to new timebase</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.multipitch.frequencies_to_midi">
<span class="sig-prename descclassname"><span class="pre">mir_eval.multipitch.</span></span><span class="sig-name descname"><span class="pre">frequencies_to_midi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frequencies</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_frequency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">440.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.multipitch.frequencies_to_midi" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts frequencies to continuous MIDI values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>frequencies</strong><span class="classifier">list of np.ndarray</span></dt><dd><p>Original frequency values</p>
</dd>
<dt><strong>ref_frequency</strong><span class="classifier">float</span></dt><dd><p>reference frequency in Hz.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>frequencies_midi</strong><span class="classifier">list of np.ndarray</span></dt><dd><p>Continuous MIDI frequency values.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.multipitch.midi_to_chroma">
<span class="sig-prename descclassname"><span class="pre">mir_eval.multipitch.</span></span><span class="sig-name descname"><span class="pre">midi_to_chroma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frequencies_midi</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.multipitch.midi_to_chroma" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrap MIDI frequencies to a single octave (chroma).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>frequencies_midi</strong><span class="classifier">list of np.ndarray</span></dt><dd><p>Continuous MIDI note frequency values.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>frequencies_chroma</strong><span class="classifier">list of np.ndarray</span></dt><dd><p>Midi values wrapped to one octave.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.multipitch.compute_num_freqs">
<span class="sig-prename descclassname"><span class="pre">mir_eval.multipitch.</span></span><span class="sig-name descname"><span class="pre">compute_num_freqs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frequencies</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.multipitch.compute_num_freqs" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the number of frequencies for each time point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>frequencies</strong><span class="classifier">list of np.ndarray</span></dt><dd><p>Frequency values</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>num_freqs</strong><span class="classifier">np.ndarray</span></dt><dd><p>Number of frequencies at each time point.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.multipitch.compute_num_true_positives">
<span class="sig-prename descclassname"><span class="pre">mir_eval.multipitch.</span></span><span class="sig-name descname"><span class="pre">compute_num_true_positives</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_freqs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_freqs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chroma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.multipitch.compute_num_true_positives" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the number of true positives in an estimate given a reference.
A frequency is correct if it is within a quartertone of the
correct frequency.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ref_freqs</strong><span class="classifier">list of np.ndarray</span></dt><dd><p>reference frequencies (MIDI)</p>
</dd>
<dt><strong>est_freqs</strong><span class="classifier">list of np.ndarray</span></dt><dd><p>estimated frequencies (MIDI)</p>
</dd>
<dt><strong>window</strong><span class="classifier">float</span></dt><dd><p>Window size, in semitones</p>
</dd>
<dt><strong>chroma</strong><span class="classifier">bool</span></dt><dd><p>If True, computes distances modulo n.
If True, <code class="docutils literal notranslate"><span class="pre">ref_freqs</span></code> and <code class="docutils literal notranslate"><span class="pre">est_freqs</span></code> should be wrapped modulo n.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>true_positives</strong><span class="classifier">np.ndarray</span></dt><dd><p>Array the same length as ref_freqs containing the number of true
positives.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.multipitch.compute_accuracy">
<span class="sig-prename descclassname"><span class="pre">mir_eval.multipitch.</span></span><span class="sig-name descname"><span class="pre">compute_accuracy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">true_positives</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_ref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_est</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.multipitch.compute_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute accuracy metrics.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>true_positives</strong><span class="classifier">np.ndarray</span></dt><dd><p>Array containing the number of true positives at each time point.</p>
</dd>
<dt><strong>n_ref</strong><span class="classifier">np.ndarray</span></dt><dd><p>Array containing the number of reference frequencies at each time
point.</p>
</dd>
<dt><strong>n_est</strong><span class="classifier">np.ndarray</span></dt><dd><p>Array containing the number of estimate frequencies at each time point.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>precision</strong><span class="classifier">float</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">sum(true_positives)/sum(n_est)</span></code></p>
</dd>
<dt><strong>recall</strong><span class="classifier">float</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">sum(true_positives)/sum(n_ref)</span></code></p>
</dd>
<dt><strong>acc</strong><span class="classifier">float</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">sum(true_positives)/sum(n_est</span> <span class="pre">+</span> <span class="pre">n_ref</span> <span class="pre">-</span> <span class="pre">true_positives)</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.multipitch.compute_err_score">
<span class="sig-prename descclassname"><span class="pre">mir_eval.multipitch.</span></span><span class="sig-name descname"><span class="pre">compute_err_score</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">true_positives</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_ref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_est</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.multipitch.compute_err_score" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute error score metrics.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>true_positives</strong><span class="classifier">np.ndarray</span></dt><dd><p>Array containing the number of true positives at each time point.</p>
</dd>
<dt><strong>n_ref</strong><span class="classifier">np.ndarray</span></dt><dd><p>Array containing the number of reference frequencies at each time
point.</p>
</dd>
<dt><strong>n_est</strong><span class="classifier">np.ndarray</span></dt><dd><p>Array containing the number of estimate frequencies at each time point.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>e_sub</strong><span class="classifier">float</span></dt><dd><p>Substitution error</p>
</dd>
<dt><strong>e_miss</strong><span class="classifier">float</span></dt><dd><p>Miss error</p>
</dd>
<dt><strong>e_fa</strong><span class="classifier">float</span></dt><dd><p>False alarm error</p>
</dd>
<dt><strong>e_tot</strong><span class="classifier">float</span></dt><dd><p>Total error</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.multipitch.metrics">
<span class="sig-prename descclassname"><span class="pre">mir_eval.multipitch.</span></span><span class="sig-name descname"><span class="pre">metrics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_freqs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_freqs</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.multipitch.metrics" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute multipitch metrics. All metrics are computed at the ‘macro’ level
such that the frame true positive/false positive/false negative rates are
summed across time and the metrics are computed on the combined values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ref_time</strong><span class="classifier">np.ndarray</span></dt><dd><p>Time of each reference frequency value</p>
</dd>
<dt><strong>ref_freqs</strong><span class="classifier">list of np.ndarray</span></dt><dd><p>List of np.ndarrays of reference frequency values</p>
</dd>
<dt><strong>est_time</strong><span class="classifier">np.ndarray</span></dt><dd><p>Time of each estimated frequency value</p>
</dd>
<dt><strong>est_freqs</strong><span class="classifier">list of np.ndarray</span></dt><dd><p>List of np.ndarrays of estimate frequency values</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>precision</strong><span class="classifier">float</span></dt><dd><p>Precision (TP/(TP + FP))</p>
</dd>
<dt><strong>recall</strong><span class="classifier">float</span></dt><dd><p>Recall (TP/(TP + FN))</p>
</dd>
<dt><strong>accuracy</strong><span class="classifier">float</span></dt><dd><p>Accuracy (TP/(TP + FP + FN))</p>
</dd>
<dt><strong>e_sub</strong><span class="classifier">float</span></dt><dd><p>Substitution error</p>
</dd>
<dt><strong>e_miss</strong><span class="classifier">float</span></dt><dd><p>Miss error</p>
</dd>
<dt><strong>e_fa</strong><span class="classifier">float</span></dt><dd><p>False alarm error</p>
</dd>
<dt><strong>e_tot</strong><span class="classifier">float</span></dt><dd><p>Total error</p>
</dd>
<dt><strong>precision_chroma</strong><span class="classifier">float</span></dt><dd><p>Chroma precision</p>
</dd>
<dt><strong>recall_chroma</strong><span class="classifier">float</span></dt><dd><p>Chroma recall</p>
</dd>
<dt><strong>accuracy_chroma</strong><span class="classifier">float</span></dt><dd><p>Chroma accuracy</p>
</dd>
<dt><strong>e_sub_chroma</strong><span class="classifier">float</span></dt><dd><p>Chroma substitution error</p>
</dd>
<dt><strong>e_miss_chroma</strong><span class="classifier">float</span></dt><dd><p>Chroma miss error</p>
</dd>
<dt><strong>e_fa_chroma</strong><span class="classifier">float</span></dt><dd><p>Chroma false alarm error</p>
</dd>
<dt><strong>e_tot_chroma</strong><span class="classifier">float</span></dt><dd><p>Chroma total error</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_time</span><span class="p">,</span> <span class="n">ref_freqs</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_ragged_time_series</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_time</span><span class="p">,</span> <span class="n">est_freqs</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_ragged_time_series</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metris_tuple</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">multipitch</span><span class="o">.</span><span class="n">metrics</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">ref_time</span><span class="p">,</span> <span class="n">ref_freqs</span><span class="p">,</span> <span class="n">est_time</span><span class="p">,</span> <span class="n">est_freqs</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.multipitch.evaluate">
<span class="sig-prename descclassname"><span class="pre">mir_eval.multipitch.</span></span><span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_freqs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_freqs</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.multipitch.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate two multipitch (multi-f0) transcriptions, where the first is
treated as the reference (ground truth) and the second as the estimate to
be evaluated (prediction).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ref_time</strong><span class="classifier">np.ndarray</span></dt><dd><p>Time of each reference frequency value</p>
</dd>
<dt><strong>ref_freqs</strong><span class="classifier">list of np.ndarray</span></dt><dd><p>List of np.ndarrays of reference frequency values</p>
</dd>
<dt><strong>est_time</strong><span class="classifier">np.ndarray</span></dt><dd><p>Time of each estimated frequency value</p>
</dd>
<dt><strong>est_freqs</strong><span class="classifier">list of np.ndarray</span></dt><dd><p>List of np.ndarrays of estimate frequency values</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scores</strong><span class="classifier">dict</span></dt><dd><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_time</span><span class="p">,</span> <span class="n">ref_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_ragged_time_series</span><span class="p">(</span><span class="s1">&#39;ref.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_time</span><span class="p">,</span> <span class="n">est_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_ragged_time_series</span><span class="p">(</span><span class="s1">&#39;est.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">multipitch</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ref_time</span><span class="p">,</span> <span class="n">ref_freq</span><span class="p">,</span>
<span class="gp">... </span>                                      <span class="n">est_time</span><span class="p">,</span> <span class="n">est_freq</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="module-mir_eval.onset">
<span id="mir-eval-onset"></span><h3><a class="reference internal" href="#module-mir_eval.onset" title="mir_eval.onset"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.onset</span></code></a><a class="headerlink" href="#module-mir_eval.onset" title="Permalink to this headline">¶</a></h3>
<p>The goal of an onset detection algorithm is to automatically determine when
notes are played in a piece of music.  The primary method used to evaluate
onset detectors is to first determine which estimated onsets are “correct”,
where correctness is defined as being within a small window of a reference
onset.</p>
<p>Based in part on this script:</p>
<blockquote>
<div><p><a class="reference external" href="https://github.com/CPJKU/onset_detection/blob/master/onset_evaluation.py">https://github.com/CPJKU/onset_detection/blob/master/onset_evaluation.py</a></p>
</div></blockquote>
<section id="id16">
<h4>Conventions<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h4>
<p>Onsets should be provided in the form of a 1-dimensional array of onset
times in seconds in increasing order.</p>
</section>
<section id="id17">
<h4>Metrics<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><a class="reference internal" href="#mir_eval.onset.f_measure" title="mir_eval.onset.f_measure"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.onset.f_measure()</span></code></a>: Precision, Recall, and F-measure scores
based on the number of esimated onsets which are sufficiently close to
reference onsets.</p></li>
</ul>
<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.onset.validate">
<span class="sig-prename descclassname"><span class="pre">mir_eval.onset.</span></span><span class="sig-name descname"><span class="pre">validate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_onsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_onsets</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.onset.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a metric look like valid onset time
arrays, and throws helpful errors if not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_onsets</strong><span class="classifier">np.ndarray</span></dt><dd><p>reference onset locations, in seconds</p>
</dd>
<dt><strong>estimated_onsets</strong><span class="classifier">np.ndarray</span></dt><dd><p>estimated onset locations, in seconds</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.onset.f_measure">
<span class="sig-prename descclassname"><span class="pre">mir_eval.onset.</span></span><span class="sig-name descname"><span class="pre">f_measure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_onsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_onsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.onset.f_measure" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the F-measure of correct vs incorrectly predicted onsets.
“Corectness” is determined over a small window.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_onsets</strong><span class="classifier">np.ndarray</span></dt><dd><p>reference onset locations, in seconds</p>
</dd>
<dt><strong>estimated_onsets</strong><span class="classifier">np.ndarray</span></dt><dd><p>estimated onset locations, in seconds</p>
</dd>
<dt><strong>window</strong><span class="classifier">float</span></dt><dd><p>Window size, in seconds
(Default value = .05)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>f_measure</strong><span class="classifier">float</span></dt><dd><p>2*precision*recall/(precision + recall)</p>
</dd>
<dt><strong>precision</strong><span class="classifier">float</span></dt><dd><p>(# true positives)/(# true positives + # false positives)</p>
</dd>
<dt><strong>recall</strong><span class="classifier">float</span></dt><dd><p>(# true positives)/(# true positives + # false negatives)</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_onsets</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_onsets</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">onset</span><span class="o">.</span><span class="n">f_measure</span><span class="p">(</span><span class="n">reference_onsets</span><span class="p">,</span>
<span class="gp">... </span>                                   <span class="n">estimated_onsets</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.onset.evaluate">
<span class="sig-prename descclassname"><span class="pre">mir_eval.onset.</span></span><span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_onsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_onsets</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.onset.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all metrics for the given reference and estimated annotations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_onsets</strong><span class="classifier">np.ndarray</span></dt><dd><p>reference onset locations, in seconds</p>
</dd>
<dt><strong>estimated_onsets</strong><span class="classifier">np.ndarray</span></dt><dd><p>estimated onset locations, in seconds</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scores</strong><span class="classifier">dict</span></dt><dd><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_onsets</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_onsets</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">onset</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">reference_onsets</span><span class="p">,</span>
<span class="gp">... </span>                                 <span class="n">estimated_onsets</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="module-mir_eval.pattern">
<span id="mir-eval-pattern"></span><h3><a class="reference internal" href="#module-mir_eval.pattern" title="mir_eval.pattern"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.pattern</span></code></a><a class="headerlink" href="#module-mir_eval.pattern" title="Permalink to this headline">¶</a></h3>
<p>Pattern discovery involves the identification of musical patterns (i.e. short
fragments or melodic ideas that repeat at least twice) both from audio and
symbolic representations.  The metrics used to evaluate pattern discovery
systems attempt to quantify the ability of the algorithm to not only determine
the present patterns in a piece, but also to find all of their occurrences.</p>
<dl class="simple">
<dt>Based on the methods described here:</dt><dd><p>T. Collins. MIREX task: Discovery of repeated themes &amp; sections.
<a class="reference external" href="http://www.music-ir.org/mirex/wiki/2013:Discovery_of_Repeated_Themes_&amp;_Sections">http://www.music-ir.org/mirex/wiki/2013:Discovery_of_Repeated_Themes_&amp;_Sections</a>,
2013.</p>
</dd>
</dl>
<section id="id18">
<h4>Conventions<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h4>
<p>The input format can be automatically generated by calling
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_patterns()</span></code></a>.  This format is a list of a list of
tuples.  The first list collections patterns, each of which is a list of
occurences, and each occurrence is a list of MIDI onset tuples of
<code class="docutils literal notranslate"><span class="pre">(onset_time,</span> <span class="pre">mid_note)</span></code></p>
<p>A pattern is a list of occurrences. The first occurrence must be the prototype
of that pattern (i.e. the most representative of all the occurrences).  An
occurrence is a list of tuples containing the onset time and the midi note
number.</p>
</section>
<section id="id19">
<h4>Metrics<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><a class="reference internal" href="#mir_eval.pattern.standard_FPR" title="mir_eval.pattern.standard_FPR"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.pattern.standard_FPR()</span></code></a>: Strict metric in order to find the
possibly transposed patterns of exact length. This is the only metric that
considers transposed patterns.</p></li>
<li><p><a class="reference internal" href="#mir_eval.pattern.establishment_FPR" title="mir_eval.pattern.establishment_FPR"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.pattern.establishment_FPR()</span></code></a>: Evaluates the amount of patterns
that were successfully identified by the estimated results, no matter how
many occurrences they found.  In other words, this metric captures how the
algorithm successfully <em>established</em> that a pattern repeated at least twice,
and this pattern is also found in the reference annotation.</p></li>
<li><p><a class="reference internal" href="#mir_eval.pattern.occurrence_FPR" title="mir_eval.pattern.occurrence_FPR"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.pattern.occurrence_FPR()</span></code></a>: Evaluation of how well an estimation
can effectively identify all the occurrences of the found patterns,
independently of how many patterns have been discovered. This metric has a
threshold parameter that indicates how similar two occurrences must be in
order to be considered equal.  In MIREX, this evaluation is run twice, with
thresholds .75 and .5.</p></li>
<li><p><a class="reference internal" href="#mir_eval.pattern.three_layer_FPR" title="mir_eval.pattern.three_layer_FPR"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.pattern.three_layer_FPR()</span></code></a>: Aims to evaluate the general
similarity between the reference and the estimations, combining both the
establishment of patterns and the retrieval of its occurrences in a single F1
score.</p></li>
<li><p><a class="reference internal" href="#mir_eval.pattern.first_n_three_layer_P" title="mir_eval.pattern.first_n_three_layer_P"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.pattern.first_n_three_layer_P()</span></code></a>: Computes the three-layer
precision for the first N patterns only in order to measure the ability of
the algorithm to sort the identified patterns based on their relevance.</p></li>
<li><p><a class="reference internal" href="#mir_eval.pattern.first_n_target_proportion_R" title="mir_eval.pattern.first_n_target_proportion_R"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.pattern.first_n_target_proportion_R()</span></code></a>: Computes the target
proportion recall for the first N patterns only in order to measure the
ability of the algorithm to sort the identified patterns based on their
relevance.</p></li>
</ul>
<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.pattern.validate">
<span class="sig-prename descclassname"><span class="pre">mir_eval.pattern.</span></span><span class="sig-name descname"><span class="pre">validate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_patterns</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_patterns</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.pattern.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a metric look like valid pattern
lists, and throws helpful errors if not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_patterns</strong><span class="classifier">list</span></dt><dd><p>The reference patterns using the format returned by
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_patterns()</span></code></a></p>
</dd>
<dt><strong>estimated_patterns</strong><span class="classifier">list</span></dt><dd><p>The estimated patterns in the same format</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"></dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.pattern.standard_FPR">
<span class="sig-prename descclassname"><span class="pre">mir_eval.pattern.</span></span><span class="sig-name descname"><span class="pre">standard_FPR</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_patterns</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_patterns</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.pattern.standard_FPR" title="Permalink to this definition">¶</a></dt>
<dd><p>Standard F1 Score, Precision and Recall.</p>
<p>This metric checks if the prototype patterns of the reference match
possible translated patterns in the prototype patterns of the estimations.
Since the sizes of these prototypes must be equal, this metric is quite
restictive and it tends to be 0 in most of 2013 MIREX results.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_patterns</strong><span class="classifier">list</span></dt><dd><p>The reference patterns using the format returned by
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_patterns()</span></code></a></p>
</dd>
<dt><strong>estimated_patterns</strong><span class="classifier">list</span></dt><dd><p>The estimated patterns in the same format</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Tolerance level when comparing reference against estimation.
Default parameter is the one found in the original matlab code by
Tom Collins used for MIREX 2013.
(Default value = 1e-5)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>f_measure</strong><span class="classifier">float</span></dt><dd><p>The standard F1 Score</p>
</dd>
<dt><strong>precision</strong><span class="classifier">float</span></dt><dd><p>The standard Precision</p>
</dd>
<dt><strong>recall</strong><span class="classifier">float</span></dt><dd><p>The standard Recall</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;ref_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;est_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">standard_FPR</span><span class="p">(</span><span class="n">ref_patterns</span><span class="p">,</span> <span class="n">est_patterns</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.pattern.establishment_FPR">
<span class="sig-prename descclassname"><span class="pre">mir_eval.pattern.</span></span><span class="sig-name descname"><span class="pre">establishment_FPR</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_patterns</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_patterns</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">similarity_metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cardinality_score'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.pattern.establishment_FPR" title="Permalink to this definition">¶</a></dt>
<dd><p>Establishment F1 Score, Precision and Recall.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>reference_patterns</strong><span class="classifier">list</span></dt><dd><p>The reference patterns in the format returned by
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_patterns()</span></code></a></p>
</dd>
<dt><strong>estimated_patterns</strong><span class="classifier">list</span></dt><dd><p>The estimated patterns in the same format</p>
</dd>
<dt><strong>similarity_metric</strong><span class="classifier">str</span></dt><dd><p>A string representing the metric to be used when computing the
similarity matrix. Accepted values:</p>
<blockquote>
<div><ul class="simple">
<li><p>“cardinality_score”: Count of the intersection
between occurrences.</p></li>
</ul>
</div></blockquote>
<p>(Default value = “cardinality_score”)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>f_measure</strong><span class="classifier">float</span></dt><dd><p>The establishment F1 Score</p>
</dd>
<dt><strong>precision</strong><span class="classifier">float</span></dt><dd><p>The establishment Precision</p>
</dd>
<dt><strong>recall</strong><span class="classifier">float</span></dt><dd><p>The establishment Recall</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;ref_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;est_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">establishment_FPR</span><span class="p">(</span><span class="n">ref_patterns</span><span class="p">,</span>
<span class="gp">... </span>                                             <span class="n">est_patterns</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.pattern.occurrence_FPR">
<span class="sig-prename descclassname"><span class="pre">mir_eval.pattern.</span></span><span class="sig-name descname"><span class="pre">occurrence_FPR</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_patterns</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_patterns</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thres</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.75</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">similarity_metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cardinality_score'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.pattern.occurrence_FPR" title="Permalink to this definition">¶</a></dt>
<dd><p>Establishment F1 Score, Precision and Recall.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>reference_patterns</strong><span class="classifier">list</span></dt><dd><p>The reference patterns in the format returned by
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_patterns()</span></code></a></p>
</dd>
<dt><strong>estimated_patterns</strong><span class="classifier">list</span></dt><dd><p>The estimated patterns in the same format</p>
</dd>
<dt><strong>thres</strong><span class="classifier">float</span></dt><dd><p>How similar two occcurrences must be in order to be considered
equal
(Default value = .75)</p>
</dd>
<dt><strong>similarity_metric</strong><span class="classifier">str</span></dt><dd><p>A string representing the metric to be used
when computing the similarity matrix. Accepted values:</p>
<blockquote>
<div><ul class="simple">
<li><p>“cardinality_score”: Count of the intersection
between occurrences.</p></li>
</ul>
</div></blockquote>
<p>(Default value = “cardinality_score”)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>f_measure</strong><span class="classifier">float</span></dt><dd><p>The establishment F1 Score</p>
</dd>
<dt><strong>precision</strong><span class="classifier">float</span></dt><dd><p>The establishment Precision</p>
</dd>
<dt><strong>recall</strong><span class="classifier">float</span></dt><dd><p>The establishment Recall</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;ref_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;est_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">occurrence_FPR</span><span class="p">(</span><span class="n">ref_patterns</span><span class="p">,</span>
<span class="gp">... </span>                                          <span class="n">est_patterns</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.pattern.three_layer_FPR">
<span class="sig-prename descclassname"><span class="pre">mir_eval.pattern.</span></span><span class="sig-name descname"><span class="pre">three_layer_FPR</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_patterns</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_patterns</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.pattern.three_layer_FPR" title="Permalink to this definition">¶</a></dt>
<dd><p>Three Layer F1 Score, Precision and Recall. As described by Meridith.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_patterns</strong><span class="classifier">list</span></dt><dd><p>The reference patterns in the format returned by
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_patterns()</span></code></a></p>
</dd>
<dt><strong>estimated_patterns</strong><span class="classifier">list</span></dt><dd><p>The estimated patterns in the same format</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>f_measure</strong><span class="classifier">float</span></dt><dd><p>The three-layer F1 Score</p>
</dd>
<dt><strong>precision</strong><span class="classifier">float</span></dt><dd><p>The three-layer Precision</p>
</dd>
<dt><strong>recall</strong><span class="classifier">float</span></dt><dd><p>The three-layer Recall</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;ref_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;est_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">three_layer_FPR</span><span class="p">(</span><span class="n">ref_patterns</span><span class="p">,</span>
<span class="gp">... </span>                                           <span class="n">est_patterns</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.pattern.first_n_three_layer_P">
<span class="sig-prename descclassname"><span class="pre">mir_eval.pattern.</span></span><span class="sig-name descname"><span class="pre">first_n_three_layer_P</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_patterns</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_patterns</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.pattern.first_n_three_layer_P" title="Permalink to this definition">¶</a></dt>
<dd><p>First n three-layer precision.</p>
<p>This metric is basically the same as the three-layer FPR but it is only
applied to the first n estimated patterns, and it only returns the
precision. In MIREX and typically, n = 5.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_patterns</strong><span class="classifier">list</span></dt><dd><p>The reference patterns in the format returned by
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_patterns()</span></code></a></p>
</dd>
<dt><strong>estimated_patterns</strong><span class="classifier">list</span></dt><dd><p>The estimated patterns in the same format</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number of patterns to consider from the estimated results, in
the order they appear in the matrix
(Default value = 5)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>precision</strong><span class="classifier">float</span></dt><dd><p>The first n three-layer Precision</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;ref_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;est_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">first_n_three_layer_P</span><span class="p">(</span><span class="n">ref_patterns</span><span class="p">,</span>
<span class="gp">... </span>                                           <span class="n">est_patterns</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.pattern.first_n_target_proportion_R">
<span class="sig-prename descclassname"><span class="pre">mir_eval.pattern.</span></span><span class="sig-name descname"><span class="pre">first_n_target_proportion_R</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_patterns</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_patterns</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.pattern.first_n_target_proportion_R" title="Permalink to this definition">¶</a></dt>
<dd><p>First n target proportion establishment recall metric.</p>
<p>This metric is similar is similar to the establishment FPR score, but it
only takes into account the first n estimated patterns and it only
outputs the Recall value of it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_patterns</strong><span class="classifier">list</span></dt><dd><p>The reference patterns in the format returned by
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_patterns()</span></code></a></p>
</dd>
<dt><strong>estimated_patterns</strong><span class="classifier">list</span></dt><dd><p>The estimated patterns in the same format</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number of patterns to consider from the estimated results, in
the order they appear in the matrix.
(Default value = 5)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>recall</strong><span class="classifier">float</span></dt><dd><p>The first n target proportion Recall.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;ref_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;est_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">first_n_target_proportion_R</span><span class="p">(</span>
<span class="gp">... </span>                                <span class="n">ref_patterns</span><span class="p">,</span> <span class="n">est_patterns</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.pattern.evaluate">
<span class="sig-prename descclassname"><span class="pre">mir_eval.pattern.</span></span><span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_patterns</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_patterns</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.pattern.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Load data and perform the evaluation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ref_patterns</strong><span class="classifier">list</span></dt><dd><p>The reference patterns in the format returned by
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_patterns()</span></code></a></p>
</dd>
<dt><strong>est_patterns</strong><span class="classifier">list</span></dt><dd><p>The estimated patterns in the same format</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scores</strong><span class="classifier">dict</span></dt><dd><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;ref_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;est_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ref_patterns</span><span class="p">,</span> <span class="n">est_patterns</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="module-mir_eval.segment">
<span id="mir-eval-segment"></span><h3><a class="reference internal" href="#module-mir_eval.segment" title="mir_eval.segment"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.segment</span></code></a><a class="headerlink" href="#module-mir_eval.segment" title="Permalink to this headline">¶</a></h3>
<p>Evaluation criteria for structural segmentation fall into two categories:
boundary annotation and structural annotation.  Boundary annotation is the task
of predicting the times at which structural changes occur, such as when a verse
transitions to a refrain.  Metrics for boundary annotation compare estimated
segment boundaries to reference boundaries.  Structural annotation is the task
of assigning labels to detected segments.  The estimated labels may be
arbitrary strings - such as A, B, C, - and they need not describe functional
concepts.  Metrics for structural annotation are similar to those used for
clustering data.</p>
<section id="id20">
<h4>Conventions<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h4>
<p>Both boundary and structural annotation metrics require two dimensional arrays
with two columns, one for boundary start times and one for boundary end times.
Structural annotation further require lists of reference and estimated segment
labels which must have a length which is equal to the number of rows in the
corresponding list of boundary edges.  In both tasks, we assume that
annotations express a partitioning of the track into intervals.  The function
<a class="reference internal" href="#mir_eval.util.adjust_intervals" title="mir_eval.util.adjust_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.util.adjust_intervals()</span></code></a> can be used to pad or crop the segment
boundaries to span the duration of the entire track.</p>
</section>
<section id="id21">
<h4>Metrics<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><a class="reference internal" href="#mir_eval.segment.detection" title="mir_eval.segment.detection"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.segment.detection()</span></code></a>: An estimated boundary is considered
correct if it falls within a window around a reference boundary
<a class="footnote-reference brackets" href="#turnbull2007" id="id22">7</a></p></li>
<li><p><a class="reference internal" href="#mir_eval.segment.deviation" title="mir_eval.segment.deviation"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.segment.deviation()</span></code></a>: Computes the median absolute time
difference from a reference boundary to its nearest estimated boundary, and
vice versa <a class="footnote-reference brackets" href="#turnbull2007" id="id23">7</a></p></li>
<li><p><a class="reference internal" href="#mir_eval.segment.pairwise" title="mir_eval.segment.pairwise"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.segment.pairwise()</span></code></a>: For classifying pairs of sampled time
instants as belonging to the same structural component <a class="footnote-reference brackets" href="#levy2008" id="id24">8</a></p></li>
<li><p><a class="reference internal" href="#mir_eval.segment.rand_index" title="mir_eval.segment.rand_index"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.segment.rand_index()</span></code></a>: Clusters reference and estimated
annotations and compares them by the Rand Index</p></li>
<li><p><a class="reference internal" href="#mir_eval.segment.ari" title="mir_eval.segment.ari"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.segment.ari()</span></code></a>: Computes the Rand index, adjusted for chance</p></li>
<li><p><a class="reference internal" href="#mir_eval.segment.nce" title="mir_eval.segment.nce"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.segment.nce()</span></code></a>: Interprets sampled reference and estimated
labels as samples of random variables <span class="math">Y_R, Y_E</span> from which the
conditional entropy of <span class="math">Y_R</span> given <span class="math">Y_E</span> (Under-Segmentation) and
<span class="math">Y_E</span> given <span class="math">Y_R</span> (Over-Segmentation) are estimated
<a class="footnote-reference brackets" href="#lukashevich2008" id="id25">9</a></p></li>
<li><p><a class="reference internal" href="#mir_eval.segment.mutual_information" title="mir_eval.segment.mutual_information"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.segment.mutual_information()</span></code></a>: Computes the standard,
normalized, and adjusted mutual information of sampled reference and
estimated segments</p></li>
<li><p><a class="reference internal" href="#mir_eval.segment.vmeasure" title="mir_eval.segment.vmeasure"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.segment.vmeasure()</span></code></a>: Computes the V-Measure, which is similar
to the conditional entropy metrics, but uses the marginal distributions
as normalization rather than the maximum entropy distribution
<a class="footnote-reference brackets" href="#rosenberg2007" id="id26">10</a></p></li>
</ul>
</section>
<section id="id27">
<h4>References<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><dl class="footnote brackets">
<dt class="label" id="turnbull2007"><span class="brackets">7</span><span class="fn-backref">(<a href="#id22">1</a>,<a href="#id23">2</a>)</span></dt>
<dd><p>Turnbull, D., Lanckriet, G. R., Pampalk, E.,
&amp; Goto, M.  A Supervised Approach for Detecting Boundaries in Music
Using Difference Features and Boosting. In ISMIR (pp. 51-54).</p>
</dd>
<dt class="label" id="levy2008"><span class="brackets"><a class="fn-backref" href="#id24">8</a></span></dt>
<dd><p>Levy, M., &amp; Sandler, M.
Structural segmentation of musical audio by constrained clustering.
IEEE transactions on audio, speech, and language processing, 16(2),
318-326.</p>
</dd>
<dt class="label" id="lukashevich2008"><span class="brackets"><a class="fn-backref" href="#id25">9</a></span></dt>
<dd><p>Lukashevich, H. M.
Towards Quantitative Measures of Evaluating Song Segmentation.
In ISMIR (pp. 375-380).</p>
</dd>
<dt class="label" id="rosenberg2007"><span class="brackets"><a class="fn-backref" href="#id26">10</a></span></dt>
<dd><p>Rosenberg, A., &amp; Hirschberg, J.
V-Measure: A Conditional Entropy-Based External Cluster Evaluation
Measure.
In EMNLP-CoNLL (Vol. 7, pp. 410-420).</p>
</dd>
</dl>
</div></blockquote>
<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.segment.validate_boundary">
<span class="sig-prename descclassname"><span class="pre">mir_eval.segment.</span></span><span class="sig-name descname"><span class="pre">validate_boundary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trim</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.segment.validate_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a segment boundary estimation
metric (i.e. one that only takes in segment intervals) look like valid
segment times, and throws helpful errors if not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_intervals</strong><span class="classifier">np.ndarray, shape=(n, 2)</span></dt><dd><p>reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_intervals()</span></code></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>estimated_intervals</strong><span class="classifier">np.ndarray, shape=(m, 2)</span></dt><dd><p>estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_intervals()</span></code></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>trim</strong><span class="classifier">bool</span></dt><dd><p>will the start and end events be trimmed?</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.segment.validate_structure">
<span class="sig-prename descclassname"><span class="pre">mir_eval.segment.</span></span><span class="sig-name descname"><span class="pre">validate_structure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_labels</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.segment.validate_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a structure estimation metric (i.e.
one that takes in both segment boundaries and their labels) look like valid
segment times and labels, and throws helpful errors if not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_intervals</strong><span class="classifier">np.ndarray, shape=(n, 2)</span></dt><dd><p>reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>reference_labels</strong><span class="classifier">list, shape=(n,)</span></dt><dd><p>reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>estimated_intervals</strong><span class="classifier">np.ndarray, shape=(m, 2)</span></dt><dd><p>estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>estimated_labels</strong><span class="classifier">list, shape=(m,)</span></dt><dd><p>estimated segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.segment.detection">
<span class="sig-prename descclassname"><span class="pre">mir_eval.segment.</span></span><span class="sig-name descname"><span class="pre">detection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.segment.detection" title="Permalink to this definition">¶</a></dt>
<dd><p>Boundary detection hit-rate.</p>
<p>A hit is counted whenever an reference boundary is within <code class="docutils literal notranslate"><span class="pre">window</span></code> of a
estimated boundary.  Note that each boundary is matched at most once: this
is achieved by computing the size of a maximal matching between reference
and estimated boundary points, subject to the window constraint.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_intervals</strong><span class="classifier">np.ndarray, shape=(n, 2)</span></dt><dd><p>reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_intervals()</span></code></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>estimated_intervals</strong><span class="classifier">np.ndarray, shape=(m, 2)</span></dt><dd><p>estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_intervals()</span></code></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>window</strong><span class="classifier">float &gt; 0</span></dt><dd><p>size of the window of ‘correctness’ around ground-truth beats
(in seconds)
(Default value = 0.5)</p>
</dd>
<dt><strong>beta</strong><span class="classifier">float &gt; 0</span></dt><dd><p>weighting constant for F-measure.
(Default value = 1.0)</p>
</dd>
<dt><strong>trim</strong><span class="classifier">boolean</span></dt><dd><p>if <code class="docutils literal notranslate"><span class="pre">True</span></code>, the first and last boundary times are ignored.
Typically, these denote start (0) and end-markers.
(Default value = False)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>precision</strong><span class="classifier">float</span></dt><dd><p>precision of estimated predictions</p>
</dd>
<dt><strong>recall</strong><span class="classifier">float</span></dt><dd><p>recall of reference reference boundaries</p>
</dd>
<dt><strong>f_measure</strong><span class="classifier">float</span></dt><dd><p>F-measure (weighted harmonic mean of <code class="docutils literal notranslate"><span class="pre">precision</span></code> and <code class="docutils literal notranslate"><span class="pre">recall</span></code>)</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># With 0.5s windowing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P05</span><span class="p">,</span> <span class="n">R05</span><span class="p">,</span> <span class="n">F05</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">detection</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                           <span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                           <span class="n">window</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># With 3s windowing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P3</span><span class="p">,</span> <span class="n">R3</span><span class="p">,</span> <span class="n">F3</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">detection</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                        <span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                        <span class="n">window</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Ignoring hits for the beginning and end of track</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">F</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">detection</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                     <span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                     <span class="n">window</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
<span class="gp">... </span>                                     <span class="n">trim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.segment.deviation">
<span class="sig-prename descclassname"><span class="pre">mir_eval.segment.</span></span><span class="sig-name descname"><span class="pre">deviation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.segment.deviation" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the median deviations between reference
and estimated boundary times.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_intervals</strong><span class="classifier">np.ndarray, shape=(n, 2)</span></dt><dd><p>reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_intervals()</span></code></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>estimated_intervals</strong><span class="classifier">np.ndarray, shape=(m, 2)</span></dt><dd><p>estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_intervals()</span></code></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>trim</strong><span class="classifier">boolean</span></dt><dd><p>if <code class="docutils literal notranslate"><span class="pre">True</span></code>, the first and last intervals are ignored.
Typically, these denote start (0.0) and end-of-track markers.
(Default value = False)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>reference_to_estimated</strong><span class="classifier">float</span></dt><dd><p>median time from each reference boundary to the
closest estimated boundary</p>
</dd>
<dt><strong>estimated_to_reference</strong><span class="classifier">float</span></dt><dd><p>median time from each estimated boundary to the
closest reference boundary</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r_to_e</span><span class="p">,</span> <span class="n">e_to_r</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">boundary</span><span class="o">.</span><span class="n">deviation</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                             <span class="n">est_intervals</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.segment.pairwise">
<span class="sig-prename descclassname"><span class="pre">mir_eval.segment.</span></span><span class="sig-name descname"><span class="pre">pairwise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.segment.pairwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Frame-clustering segmentation evaluation by pair-wise agreement.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_intervals</strong><span class="classifier">np.ndarray, shape=(n, 2)</span></dt><dd><p>reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>reference_labels</strong><span class="classifier">list, shape=(n,)</span></dt><dd><p>reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>estimated_intervals</strong><span class="classifier">np.ndarray, shape=(m, 2)</span></dt><dd><p>estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>estimated_labels</strong><span class="classifier">list, shape=(m,)</span></dt><dd><p>estimated segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>frame_size</strong><span class="classifier">float &gt; 0</span></dt><dd><p>length (in seconds) of frames for clustering
(Default value = 0.1)</p>
</dd>
<dt><strong>beta</strong><span class="classifier">float &gt; 0</span></dt><dd><p>beta value for F-measure
(Default value = 1.0)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>precision</strong><span class="classifier">float &gt; 0</span></dt><dd><p>Precision of detecting whether frames belong in the same cluster</p>
</dd>
<dt><strong>recall</strong><span class="classifier">float &gt; 0</span></dt><dd><p>Recall of detecting whether frames belong in the same cluster</p>
</dd>
<dt><strong>f</strong><span class="classifier">float &gt; 0</span></dt><dd><p>F-measure of detecting whether frames belong in the same cluster</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Trim or pad the estimate to match reference timing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_max</span><span class="o">=</span><span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">precision</span><span class="p">,</span> <span class="n">recall</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">pairwise</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                                   <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                                   <span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                                   <span class="n">est_labels</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.segment.rand_index">
<span class="sig-prename descclassname"><span class="pre">mir_eval.segment.</span></span><span class="sig-name descname"><span class="pre">rand_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.segment.rand_index" title="Permalink to this definition">¶</a></dt>
<dd><p>(Non-adjusted) Rand index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_intervals</strong><span class="classifier">np.ndarray, shape=(n, 2)</span></dt><dd><p>reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>reference_labels</strong><span class="classifier">list, shape=(n,)</span></dt><dd><p>reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>estimated_intervals</strong><span class="classifier">np.ndarray, shape=(m, 2)</span></dt><dd><p>estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>estimated_labels</strong><span class="classifier">list, shape=(m,)</span></dt><dd><p>estimated segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>frame_size</strong><span class="classifier">float &gt; 0</span></dt><dd><p>length (in seconds) of frames for clustering
(Default value = 0.1)</p>
</dd>
<dt><strong>beta</strong><span class="classifier">float &gt; 0</span></dt><dd><p>beta value for F-measure
(Default value = 1.0)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rand_index</strong><span class="classifier">float &gt; 0</span></dt><dd><p>Rand index</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Trim or pad the estimate to match reference timing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_max</span><span class="o">=</span><span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rand_index</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">rand_index</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                           <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                           <span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                           <span class="n">est_labels</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.segment.ari">
<span class="sig-prename descclassname"><span class="pre">mir_eval.segment.</span></span><span class="sig-name descname"><span class="pre">ari</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.segment.ari" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjusted Rand Index (ARI) for frame clustering segmentation evaluation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_intervals</strong><span class="classifier">np.ndarray, shape=(n, 2)</span></dt><dd><p>reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>reference_labels</strong><span class="classifier">list, shape=(n,)</span></dt><dd><p>reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>estimated_intervals</strong><span class="classifier">np.ndarray, shape=(m, 2)</span></dt><dd><p>estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>estimated_labels</strong><span class="classifier">list, shape=(m,)</span></dt><dd><p>estimated segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>frame_size</strong><span class="classifier">float &gt; 0</span></dt><dd><p>length (in seconds) of frames for clustering
(Default value = 0.1)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ari_score</strong><span class="classifier">float &gt; 0</span></dt><dd><p>Adjusted Rand index between segmentations.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Trim or pad the estimate to match reference timing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_max</span><span class="o">=</span><span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ari_score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">ari</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                   <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.segment.mutual_information">
<span class="sig-prename descclassname"><span class="pre">mir_eval.segment.</span></span><span class="sig-name descname"><span class="pre">mutual_information</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.segment.mutual_information" title="Permalink to this definition">¶</a></dt>
<dd><p>Frame-clustering segmentation: mutual information metrics.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_intervals</strong><span class="classifier">np.ndarray, shape=(n, 2)</span></dt><dd><p>reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>reference_labels</strong><span class="classifier">list, shape=(n,)</span></dt><dd><p>reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>estimated_intervals</strong><span class="classifier">np.ndarray, shape=(m, 2)</span></dt><dd><p>estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>estimated_labels</strong><span class="classifier">list, shape=(m,)</span></dt><dd><p>estimated segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>frame_size</strong><span class="classifier">float &gt; 0</span></dt><dd><p>length (in seconds) of frames for clustering
(Default value = 0.1)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>MI</strong><span class="classifier">float &gt; 0</span></dt><dd><p>Mutual information between segmentations</p>
</dd>
<dt><strong>AMI</strong><span class="classifier">float</span></dt><dd><p>Adjusted mutual information between segmentations.</p>
</dd>
<dt><strong>NMI</strong><span class="classifier">float &gt; 0</span></dt><dd><p>Normalize mutual information between segmentations</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Trim or pad the estimate to match reference timing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_max</span><span class="o">=</span><span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mi</span><span class="p">,</span> <span class="n">ami</span><span class="p">,</span> <span class="n">nmi</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">mutual_information</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                                     <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                                     <span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                                     <span class="n">est_labels</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.segment.nce">
<span class="sig-prename descclassname"><span class="pre">mir_eval.segment.</span></span><span class="sig-name descname"><span class="pre">nce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">marginal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.segment.nce" title="Permalink to this definition">¶</a></dt>
<dd><p>Frame-clustering segmentation: normalized conditional entropy</p>
<p>Computes cross-entropy of cluster assignment, normalized by the
max-entropy.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_intervals</strong><span class="classifier">np.ndarray, shape=(n, 2)</span></dt><dd><p>reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>reference_labels</strong><span class="classifier">list, shape=(n,)</span></dt><dd><p>reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>estimated_intervals</strong><span class="classifier">np.ndarray, shape=(m, 2)</span></dt><dd><p>estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>estimated_labels</strong><span class="classifier">list, shape=(m,)</span></dt><dd><p>estimated segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>frame_size</strong><span class="classifier">float &gt; 0</span></dt><dd><p>length (in seconds) of frames for clustering
(Default value = 0.1)</p>
</dd>
<dt><strong>beta</strong><span class="classifier">float &gt; 0</span></dt><dd><p>beta for F-measure
(Default value = 1.0)</p>
</dd>
<dt><strong>marginal</strong><span class="classifier">bool</span></dt><dd><p>If <cite>False</cite>, normalize conditional entropy by uniform entropy.
If <cite>True</cite>, normalize conditional entropy by the marginal entropy.
(Default value = False)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt>S_over</dt><dd><p>Over-clustering score:</p>
<ul class="simple">
<li><p>For <cite>marginal=False</cite>, <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">-</span> <span class="pre">H(y_est</span> <span class="pre">|</span> <span class="pre">y_ref)</span> <span class="pre">/</span> <span class="pre">log(|y_est|)</span></code></p></li>
<li><p>For <cite>marginal=True</cite>, <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">-</span> <span class="pre">H(y_est</span> <span class="pre">|</span> <span class="pre">y_ref)</span> <span class="pre">/</span> <span class="pre">H(y_est)</span></code></p></li>
</ul>
<p>If <cite>|y_est|==1</cite>, then <cite>S_over</cite> will be 0.</p>
</dd>
<dt>S_under</dt><dd><p>Under-clustering score:</p>
<ul class="simple">
<li><p>For <cite>marginal=False</cite>, <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">-</span> <span class="pre">H(y_ref</span> <span class="pre">|</span> <span class="pre">y_est)</span> <span class="pre">/</span> <span class="pre">log(|y_ref|)</span></code></p></li>
<li><p>For <cite>marginal=True</cite>, <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">-</span> <span class="pre">H(y_ref</span> <span class="pre">|</span> <span class="pre">y_est)</span> <span class="pre">/</span> <span class="pre">H(y_ref)</span></code></p></li>
</ul>
<p>If <cite>|y_ref|==1</cite>, then <cite>S_under</cite> will be 0.</p>
</dd>
<dt>S_F</dt><dd><p>F-measure for (S_over, S_under)</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Trim or pad the estimate to match reference timing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_max</span><span class="o">=</span><span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S_over</span><span class="p">,</span> <span class="n">S_under</span><span class="p">,</span> <span class="n">S_F</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">nce</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">est_labels</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.segment.vmeasure">
<span class="sig-prename descclassname"><span class="pre">mir_eval.segment.</span></span><span class="sig-name descname"><span class="pre">vmeasure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.segment.vmeasure" title="Permalink to this definition">¶</a></dt>
<dd><p>Frame-clustering segmentation: v-measure</p>
<p>Computes cross-entropy of cluster assignment, normalized by the
marginal-entropy.</p>
<p>This is equivalent to <cite>nce(…, marginal=True)</cite>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_intervals</strong><span class="classifier">np.ndarray, shape=(n, 2)</span></dt><dd><p>reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>reference_labels</strong><span class="classifier">list, shape=(n,)</span></dt><dd><p>reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>estimated_intervals</strong><span class="classifier">np.ndarray, shape=(m, 2)</span></dt><dd><p>estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>estimated_labels</strong><span class="classifier">list, shape=(m,)</span></dt><dd><p>estimated segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>frame_size</strong><span class="classifier">float &gt; 0</span></dt><dd><p>length (in seconds) of frames for clustering
(Default value = 0.1)</p>
</dd>
<dt><strong>beta</strong><span class="classifier">float &gt; 0</span></dt><dd><p>beta for F-measure
(Default value = 1.0)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt>V_precision</dt><dd><p>Over-clustering score:
<code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">-</span> <span class="pre">H(y_est</span> <span class="pre">|</span> <span class="pre">y_ref)</span> <span class="pre">/</span> <span class="pre">H(y_est)</span></code></p>
<p>If <cite>|y_est|==1</cite>, then <cite>V_precision</cite> will be 0.</p>
</dd>
<dt>V_recall</dt><dd><p>Under-clustering score:
<code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">-</span> <span class="pre">H(y_ref</span> <span class="pre">|</span> <span class="pre">y_est)</span> <span class="pre">/</span> <span class="pre">H(y_ref)</span></code></p>
<p>If <cite>|y_ref|==1</cite>, then <cite>V_recall</cite> will be 0.</p>
</dd>
<dt>V_F</dt><dd><p>F-measure for (V_precision, V_recall)</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Trim or pad the estimate to match reference timing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_max</span><span class="o">=</span><span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">V_precision</span><span class="p">,</span> <span class="n">V_recall</span><span class="p">,</span> <span class="n">V_F</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">vmeasure</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                                         <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                                         <span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                                         <span class="n">est_labels</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.segment.evaluate">
<span class="sig-prename descclassname"><span class="pre">mir_eval.segment.</span></span><span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_labels</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.segment.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all metrics for the given reference and estimated annotations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ref_intervals</strong><span class="classifier">np.ndarray, shape=(n, 2)</span></dt><dd><p>reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>ref_labels</strong><span class="classifier">list, shape=(n,)</span></dt><dd><p>reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>est_intervals</strong><span class="classifier">np.ndarray, shape=(m, 2)</span></dt><dd><p>estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>est_labels</strong><span class="classifier">list, shape=(m,)</span></dt><dd><p>estimated segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scores</strong><span class="classifier">dict</span></dt><dd><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                   <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="module-mir_eval.hierarchy">
<span id="mir-eval-hierarchy"></span><h3><a class="reference internal" href="#module-mir_eval.hierarchy" title="mir_eval.hierarchy"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.hierarchy</span></code></a><a class="headerlink" href="#module-mir_eval.hierarchy" title="Permalink to this headline">¶</a></h3>
<p>Evaluation criteria for hierarchical structure analysis.</p>
<p>Hierarchical structure analysis seeks to annotate a track with a nested
decomposition of the temporal elements of the piece, effectively providing
a kind of “parse tree” of the composition.  Unlike the flat segmentation
metrics defined in <a class="reference internal" href="#module-mir_eval.segment" title="mir_eval.segment"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.segment</span></code></a>, which can only encode one level of
analysis, hierarchical annotations expose the relationships between short
segments and the larger compositional elements to which they belong.</p>
<section id="id28">
<h4>Conventions<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h4>
<p>Annotations are assumed to take the form of an ordered list of segmentations.
As in the <a class="reference internal" href="#module-mir_eval.segment" title="mir_eval.segment"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.segment</span></code></a> metrics, each segmentation itself consists of
an n-by-2 array of interval times, so that the <code class="docutils literal notranslate"><span class="pre">i</span></code> th segment spans time
<code class="docutils literal notranslate"><span class="pre">intervals[i,</span> <span class="pre">0]</span></code> to <code class="docutils literal notranslate"><span class="pre">intervals[i,</span> <span class="pre">1]</span></code>.</p>
<p>Hierarchical annotations are ordered by increasing specificity, so that the
first segmentation should contain the fewest segments, and the last
segmentation contains the most.</p>
</section>
<section id="id29">
<h4>Metrics<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><a class="reference internal" href="#mir_eval.hierarchy.tmeasure" title="mir_eval.hierarchy.tmeasure"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.hierarchy.tmeasure()</span></code></a>: Precision, recall, and F-measure of
triplet-based frame accuracy for boundary detection.</p></li>
<li><p><a class="reference internal" href="#mir_eval.hierarchy.lmeasure" title="mir_eval.hierarchy.lmeasure"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.hierarchy.lmeasure()</span></code></a>: Precision, recall, and F-measure of
triplet-based frame accuracy for segment labeling.</p></li>
</ul>
</section>
<section id="id30">
<h4>References<a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><dl class="footnote brackets">
<dt class="label" id="mcfee2015"><span class="brackets">11</span></dt>
<dd><p>Brian McFee, Oriol Nieto, and Juan P. Bello.
“Hierarchical evaluation of segment boundary detection”,
International Society for Music Information Retrieval (ISMIR) conference,
2015.</p>
</dd>
<dt class="label" id="mcfee2017"><span class="brackets">12</span></dt>
<dd><p>Brian McFee, Oriol Nieto, Morwaread Farbood, and
Juan P. Bello.
“Evaluating hierarchical structure in music annotations”,
Frontiers in Psychology, 2017.</p>
</dd>
</dl>
</div></blockquote>
<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.hierarchy.validate_hier_intervals">
<span class="sig-prename descclassname"><span class="pre">mir_eval.hierarchy.</span></span><span class="sig-name descname"><span class="pre">validate_hier_intervals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intervals_hier</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.hierarchy.validate_hier_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate a hierarchical segment annotation.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>intervals_hier</strong><span class="classifier">ordered list of segmentations</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl>
<dt>ValueError</dt><dd><p>If any segmentation does not span the full duration of the top-level
segmentation.</p>
<p>If any segmentation does not start at 0.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.hierarchy.tmeasure">
<span class="sig-prename descclassname"><span class="pre">mir_eval.hierarchy.</span></span><span class="sig-name descname"><span class="pre">tmeasure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_intervals_hier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_intervals_hier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transitive</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">15.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.hierarchy.tmeasure" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the tree measures for hierarchical segment annotations.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_intervals_hier</strong><span class="classifier">list of ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">reference_intervals_hier[i]</span></code> contains the segment intervals
(in seconds) for the <code class="docutils literal notranslate"><span class="pre">i</span></code> th layer of the annotations.  Layers are
ordered from top to bottom, so that the last list of intervals should
be the most specific.</p>
</dd>
<dt><strong>estimated_intervals_hier</strong><span class="classifier">list of ndarray</span></dt><dd><p>Like <code class="docutils literal notranslate"><span class="pre">reference_intervals_hier</span></code> but for the estimated annotation</p>
</dd>
<dt><strong>transitive</strong><span class="classifier">bool</span></dt><dd><p>whether to compute the t-measures using transitivity or not.</p>
</dd>
<dt><strong>window</strong><span class="classifier">float &gt; 0</span></dt><dd><p>size of the window (in seconds).  For each query frame q,
result frames are only counted within q +- window.</p>
</dd>
<dt><strong>frame_size</strong><span class="classifier">float &gt; 0</span></dt><dd><p>length (in seconds) of frames.  The frame size cannot be longer than
the window.</p>
</dd>
<dt><strong>beta</strong><span class="classifier">float &gt; 0</span></dt><dd><p>beta parameter for the F-measure.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>t_precision</strong><span class="classifier">number [0, 1]</span></dt><dd><p>T-measure Precision</p>
</dd>
<dt><strong>t_recall</strong><span class="classifier">number [0, 1]</span></dt><dd><p>T-measure Recall</p>
</dd>
<dt><strong>t_measure</strong><span class="classifier">number [0, 1]</span></dt><dd><p>F-beta measure for <code class="docutils literal notranslate"><span class="pre">(t_precision,</span> <span class="pre">t_recall)</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl>
<dt>ValueError</dt><dd><p>If either of the input hierarchies are inconsistent</p>
<p>If the input hierarchies have different time durations</p>
<p>If <code class="docutils literal notranslate"><span class="pre">frame_size</span> <span class="pre">&gt;</span> <span class="pre">window</span></code> or <code class="docutils literal notranslate"><span class="pre">frame_size</span> <span class="pre">&lt;=</span> <span class="pre">0</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.hierarchy.lmeasure">
<span class="sig-prename descclassname"><span class="pre">mir_eval.hierarchy.</span></span><span class="sig-name descname"><span class="pre">lmeasure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_intervals_hier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference_labels_hier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_intervals_hier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_labels_hier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.hierarchy.lmeasure" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the tree measures for hierarchical segment annotations.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_intervals_hier</strong><span class="classifier">list of ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">reference_intervals_hier[i]</span></code> contains the segment intervals
(in seconds) for the <code class="docutils literal notranslate"><span class="pre">i</span></code> th layer of the annotations.  Layers are
ordered from top to bottom, so that the last list of intervals should
be the most specific.</p>
</dd>
<dt><strong>reference_labels_hier</strong><span class="classifier">list of list of str</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">reference_labels_hier[i]</span></code> contains the segment labels for the
<a href="#id31"><span class="problematic" id="id32">``</span></a>i``th layer of the annotations</p>
</dd>
<dt><strong>estimated_intervals_hier</strong><span class="classifier">list of ndarray</span></dt><dd></dd>
<dt><strong>estimated_labels_hier</strong><span class="classifier">list of ndarray</span></dt><dd><p>Like <code class="docutils literal notranslate"><span class="pre">reference_intervals_hier</span></code> and <code class="docutils literal notranslate"><span class="pre">reference_labels_hier</span></code>
but for the estimated annotation</p>
</dd>
<dt><strong>frame_size</strong><span class="classifier">float &gt; 0</span></dt><dd><p>length (in seconds) of frames.  The frame size cannot be longer than
the window.</p>
</dd>
<dt><strong>beta</strong><span class="classifier">float &gt; 0</span></dt><dd><p>beta parameter for the F-measure.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>l_precision</strong><span class="classifier">number [0, 1]</span></dt><dd><p>L-measure Precision</p>
</dd>
<dt><strong>l_recall</strong><span class="classifier">number [0, 1]</span></dt><dd><p>L-measure Recall</p>
</dd>
<dt><strong>l_measure</strong><span class="classifier">number [0, 1]</span></dt><dd><p>F-beta measure for <code class="docutils literal notranslate"><span class="pre">(l_precision,</span> <span class="pre">l_recall)</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl>
<dt>ValueError</dt><dd><p>If either of the input hierarchies are inconsistent</p>
<p>If the input hierarchies have different time durations</p>
<p>If <code class="docutils literal notranslate"><span class="pre">frame_size</span> <span class="pre">&gt;</span> <span class="pre">window</span></code> or <code class="docutils literal notranslate"><span class="pre">frame_size</span> <span class="pre">&lt;=</span> <span class="pre">0</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.hierarchy.evaluate">
<span class="sig-prename descclassname"><span class="pre">mir_eval.hierarchy.</span></span><span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_intervals_hier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_labels_hier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_intervals_hier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_labels_hier</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.hierarchy.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all hierarchical structure metrics for the given reference and
estimated annotations.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ref_intervals_hier</strong><span class="classifier">list of list-like</span></dt><dd></dd>
<dt><strong>ref_labels_hier</strong><span class="classifier">list of list of str</span></dt><dd></dd>
<dt><strong>est_intervals_hier</strong><span class="classifier">list of list-like</span></dt><dd></dd>
<dt><strong>est_labels_hier</strong><span class="classifier">list of list of str</span></dt><dd><p>Hierarchical annotations are encoded as an ordered list
of segmentations.  Each segmentation itself is a list (or list-like)
of intervals (*_intervals_hier) and a list of lists of labels
(*_labels_hier).</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>additional keyword arguments to the evaluation metrics.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>scores</strong><span class="classifier">OrderedDict</span></dt><dd><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
<p>T-measures are computed in both the “full” (<code class="docutils literal notranslate"><span class="pre">transitive=True</span></code>) and
“reduced” (<code class="docutils literal notranslate"><span class="pre">transitive=False</span></code>) modes.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>A toy example with two two-layer annotations</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_i</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">60</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span> <span class="p">[</span><span class="mi">15</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">45</span><span class="p">],</span> <span class="p">[</span><span class="mi">45</span><span class="p">,</span> <span class="mi">60</span><span class="p">]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_i</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">45</span><span class="p">],</span> <span class="p">[</span><span class="mi">45</span><span class="p">,</span> <span class="mi">60</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span> <span class="p">[</span><span class="mi">15</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">45</span><span class="p">],</span> <span class="p">[</span><span class="mi">45</span><span class="p">,</span> <span class="mi">60</span><span class="p">]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ref_l</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]</span> <span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_l</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">hierarchy</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ref_i</span><span class="p">,</span> <span class="n">ref_l</span><span class="p">,</span> <span class="n">est_i</span><span class="p">,</span> <span class="n">est_l</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dict</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>
<span class="go">{&#39;T-Measure full&#39;: 0.94822745804853459,</span>
<span class="go"> &#39;T-Measure reduced&#39;: 0.8732458222764804,</span>
<span class="go"> &#39;T-Precision full&#39;: 0.96569179094693058,</span>
<span class="go"> &#39;T-Precision reduced&#39;: 0.89939075137018787,</span>
<span class="go"> &#39;T-Recall full&#39;: 0.93138358189386117,</span>
<span class="go"> &#39;T-Recall reduced&#39;: 0.84857799953694923}</span>
</pre></div>
</div>
<p>A more realistic example, using SALAMI pre-parsed annotations</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">load_salami</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
<span class="gp">... </span>    <span class="s2">&quot;load SALAMI event format as labeled intervals&quot;</span>
<span class="gp">... </span>    <span class="n">events</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_events</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">intervals</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">boundaries_to_intervals</span><span class="p">(</span><span class="n">events</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">intervals</span><span class="p">,</span> <span class="n">labels</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">intervals</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ref_files</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;data/10/parsed/textfile1_uppercase.txt&#39;</span><span class="p">,</span>
<span class="gp">... </span>             <span class="s1">&#39;data/10/parsed/textfile1_lowercase.txt&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_files</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;data/10/parsed/textfile2_uppercase.txt&#39;</span><span class="p">,</span>
<span class="gp">... </span>             <span class="s1">&#39;data/10/parsed/textfile2_lowercase.txt&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ref</span> <span class="o">=</span> <span class="p">[</span><span class="n">load_salami</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span> <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">ref_files</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ref_int</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">ref</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ref_lab</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">ref</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est</span> <span class="o">=</span> <span class="p">[</span><span class="n">load_salami</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span> <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">est_files</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_int</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">est</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_lab</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">est</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">hierarchy</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ref_int</span><span class="p">,</span> <span class="n">ref_lab</span><span class="p">,</span>
<span class="gp">... </span>                                     <span class="n">est_hier</span><span class="p">,</span> <span class="n">est_lab</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dict</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>
<span class="go">{&#39;T-Measure full&#39;: 0.66029225561405358,</span>
<span class="go"> &#39;T-Measure reduced&#39;: 0.62001868041578034,</span>
<span class="go"> &#39;T-Precision full&#39;: 0.66844764668949885,</span>
<span class="go"> &#39;T-Precision reduced&#39;: 0.63252297209957919,</span>
<span class="go"> &#39;T-Recall full&#39;: 0.6523334654992341,</span>
<span class="go"> &#39;T-Recall reduced&#39;: 0.60799919710921635}</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="module-mir_eval.separation">
<span id="mir-eval-separation"></span><h3><a class="reference internal" href="#module-mir_eval.separation" title="mir_eval.separation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.separation</span></code></a><a class="headerlink" href="#module-mir_eval.separation" title="Permalink to this headline">¶</a></h3>
<p>Source separation algorithms attempt to extract recordings of individual
sources from a recording of a mixture of sources.  Evaluation methods for
source separation compare the extracted sources from reference sources and
attempt to measure the perceptual quality of the separation.</p>
<dl class="simple">
<dt>See also the bss_eval MATLAB toolbox:</dt><dd><p><a class="reference external" href="http://bass-db.gforge.inria.fr/bss_eval/">http://bass-db.gforge.inria.fr/bss_eval/</a></p>
</dd>
</dl>
<section id="id33">
<h4>Conventions<a class="headerlink" href="#id33" title="Permalink to this headline">¶</a></h4>
<p>An audio signal is expected to be in the format of a 1-dimensional array where
the entries are the samples of the audio signal.  When providing a group of
estimated or reference sources, they should be provided in a 2-dimensional
array, where the first dimension corresponds to the source number and the
second corresponds to the samples.</p>
</section>
<section id="id34">
<h4>Metrics<a class="headerlink" href="#id34" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><a class="reference internal" href="#mir_eval.separation.bss_eval_sources" title="mir_eval.separation.bss_eval_sources"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.separation.bss_eval_sources()</span></code></a>: Computes the bss_eval_sources
metrics from bss_eval, which optionally optimally match the estimated sources
to the reference sources and measure the distortion and artifacts present in
the estimated sources as well as the interference between them.</p></li>
<li><p><a class="reference internal" href="#mir_eval.separation.bss_eval_sources_framewise" title="mir_eval.separation.bss_eval_sources_framewise"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.separation.bss_eval_sources_framewise()</span></code></a>: Computes the
bss_eval_sources metrics on a frame-by-frame basis.</p></li>
<li><p><a class="reference internal" href="#mir_eval.separation.bss_eval_images" title="mir_eval.separation.bss_eval_images"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.separation.bss_eval_images()</span></code></a>: Computes the bss_eval_images
metrics from bss_eval, which includes the metrics in
<a class="reference internal" href="#mir_eval.separation.bss_eval_sources" title="mir_eval.separation.bss_eval_sources"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.separation.bss_eval_sources()</span></code></a> plus the image to spatial
distortion ratio.</p></li>
<li><p><a class="reference internal" href="#mir_eval.separation.bss_eval_images_framewise" title="mir_eval.separation.bss_eval_images_framewise"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.separation.bss_eval_images_framewise()</span></code></a>: Computes the
bss_eval_images metrics on a frame-by-frame basis.</p></li>
</ul>
</section>
<section id="id35">
<h4>References<a class="headerlink" href="#id35" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><dl class="footnote brackets">
<dt class="label" id="vincent2006performance"><span class="brackets">13</span><span class="fn-backref">(<a href="#id36">1</a>,<a href="#id38">2</a>)</span></dt>
<dd><p>Emmanuel Vincent, Rémi Gribonval, and Cédric
Févotte, “Performance measurement in blind audio source separation,” IEEE
Trans. on Audio, Speech and Language Processing, 14(4):1462-1469, 2006.</p>
</dd>
</dl>
</div></blockquote>
<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.separation.validate">
<span class="sig-prename descclassname"><span class="pre">mir_eval.separation.</span></span><span class="sig-name descname"><span class="pre">validate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_sources</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_sources</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.separation.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input data to a metric are valid, and throws helpful
errors if not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_sources</strong><span class="classifier">np.ndarray, shape=(nsrc, nsampl)</span></dt><dd><p>matrix containing true sources</p>
</dd>
<dt><strong>estimated_sources</strong><span class="classifier">np.ndarray, shape=(nsrc, nsampl)</span></dt><dd><p>matrix containing estimated sources</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.separation.bss_eval_sources">
<span class="sig-prename descclassname"><span class="pre">mir_eval.separation.</span></span><span class="sig-name descname"><span class="pre">bss_eval_sources</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_sources</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_sources</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_permutation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.separation.bss_eval_sources" title="Permalink to this definition">¶</a></dt>
<dd><p>Ordering and measurement of the separation quality for estimated source
signals in terms of filtered true source, interference and artifacts.</p>
<p>The decomposition allows a time-invariant filter distortion of length
512, as described in Section III.B of <a class="footnote-reference brackets" href="#vincent2006performance" id="id36">13</a>.</p>
<p>Passing <code class="docutils literal notranslate"><span class="pre">False</span></code> for <code class="docutils literal notranslate"><span class="pre">compute_permutation</span></code> will improve the computation
performance of the evaluation; however, it is not always appropriate and
is not the way that the BSS_EVAL Matlab toolbox computes bss_eval_sources.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_sources</strong><span class="classifier">np.ndarray, shape=(nsrc, nsampl)</span></dt><dd><p>matrix containing true sources (must have same shape as
estimated_sources)</p>
</dd>
<dt><strong>estimated_sources</strong><span class="classifier">np.ndarray, shape=(nsrc, nsampl)</span></dt><dd><p>matrix containing estimated sources (must have same shape as
reference_sources)</p>
</dd>
<dt><strong>compute_permutation</strong><span class="classifier">bool, optional</span></dt><dd><p>compute permutation of estimate/source combinations (True by default)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>sdr</strong><span class="classifier">np.ndarray, shape=(nsrc,)</span></dt><dd><p>vector of Signal to Distortion Ratios (SDR)</p>
</dd>
<dt><strong>sir</strong><span class="classifier">np.ndarray, shape=(nsrc,)</span></dt><dd><p>vector of Source to Interference Ratios (SIR)</p>
</dd>
<dt><strong>sar</strong><span class="classifier">np.ndarray, shape=(nsrc,)</span></dt><dd><p>vector of Sources to Artifacts Ratios (SAR)</p>
</dd>
<dt><strong>perm</strong><span class="classifier">np.ndarray, shape=(nsrc,)</span></dt><dd><p>vector containing the best ordering of estimated sources in
the mean SIR sense (estimated source number <code class="docutils literal notranslate"><span class="pre">perm[j]</span></code> corresponds to
true source number <code class="docutils literal notranslate"><span class="pre">j</span></code>). Note: <code class="docutils literal notranslate"><span class="pre">perm</span></code> will be <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">...,</span>
<span class="pre">nsrc-1]</span></code> if <code class="docutils literal notranslate"><span class="pre">compute_permutation</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id37"><span class="brackets">14</span></dt>
<dd><p>Emmanuel Vincent, Shoko Araki, Fabian J. Theis, Guido Nolte, Pau
Bofill, Hiroshi Sawada, Alexey Ozerov, B. Vikrham Gowreesunker, Dominik
Lutter and Ngoc Q.K. Duong, “The Signal Separation Evaluation Campaign
(2007-2010): Achievements and remaining challenges”, Signal Processing,
92, pp. 1928-1936, 2012.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># reference_sources[n] should be an ndarray of samples of the</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># n&#39;th reference source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># estimated_sources[n] should be the same for the n&#39;th estimated</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">sdr</span><span class="p">,</span> <span class="n">sir</span><span class="p">,</span> <span class="n">sar</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">perm</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">separation</span><span class="o">.</span><span class="n">bss_eval_sources</span><span class="p">(</span><span class="n">reference_sources</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">estimated_sources</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.separation.bss_eval_sources_framewise">
<span class="sig-prename descclassname"><span class="pre">mir_eval.separation.</span></span><span class="sig-name descname"><span class="pre">bss_eval_sources_framewise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_sources</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_sources</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1323000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">661500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_permutation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.separation.bss_eval_sources_framewise" title="Permalink to this definition">¶</a></dt>
<dd><p>Framewise computation of bss_eval_sources</p>
<p>Please be aware that this function does not compute permutations (by
default) on the possible relations between reference_sources and
estimated_sources due to the dangers of a changing permutation. Therefore
(by default), it assumes that <code class="docutils literal notranslate"><span class="pre">reference_sources[i]</span></code> corresponds to
<code class="docutils literal notranslate"><span class="pre">estimated_sources[i]</span></code>. To enable computing permutations please set
<code class="docutils literal notranslate"><span class="pre">compute_permutation</span></code> to be <code class="docutils literal notranslate"><span class="pre">True</span></code> and check that the returned <code class="docutils literal notranslate"><span class="pre">perm</span></code>
is identical for all windows.</p>
<p>NOTE: if <code class="docutils literal notranslate"><span class="pre">reference_sources</span></code> and <code class="docutils literal notranslate"><span class="pre">estimated_sources</span></code> would be evaluated
using only a single window or are shorter than the window length, the
result of <a class="reference internal" href="#mir_eval.separation.bss_eval_sources" title="mir_eval.separation.bss_eval_sources"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.separation.bss_eval_sources()</span></code></a> called on
<code class="docutils literal notranslate"><span class="pre">reference_sources</span></code> and <code class="docutils literal notranslate"><span class="pre">estimated_sources</span></code> (with the
<code class="docutils literal notranslate"><span class="pre">compute_permutation</span></code> parameter passed to
<a class="reference internal" href="#mir_eval.separation.bss_eval_sources" title="mir_eval.separation.bss_eval_sources"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.separation.bss_eval_sources()</span></code></a>) is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_sources</strong><span class="classifier">np.ndarray, shape=(nsrc, nsampl)</span></dt><dd><p>matrix containing true sources (must have the same shape as
<code class="docutils literal notranslate"><span class="pre">estimated_sources</span></code>)</p>
</dd>
<dt><strong>estimated_sources</strong><span class="classifier">np.ndarray, shape=(nsrc, nsampl)</span></dt><dd><p>matrix containing estimated sources (must have the same shape as
<code class="docutils literal notranslate"><span class="pre">reference_sources</span></code>)</p>
</dd>
<dt><strong>window</strong><span class="classifier">int, optional</span></dt><dd><p>Window length for framewise evaluation (default value is 30s at a
sample rate of 44.1kHz)</p>
</dd>
<dt><strong>hop</strong><span class="classifier">int, optional</span></dt><dd><p>Hop size for framewise evaluation (default value is 15s at a
sample rate of 44.1kHz)</p>
</dd>
<dt><strong>compute_permutation</strong><span class="classifier">bool, optional</span></dt><dd><p>compute permutation of estimate/source combinations for all windows
(False by default)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>sdr</strong><span class="classifier">np.ndarray, shape=(nsrc, nframes)</span></dt><dd><p>vector of Signal to Distortion Ratios (SDR)</p>
</dd>
<dt><strong>sir</strong><span class="classifier">np.ndarray, shape=(nsrc, nframes)</span></dt><dd><p>vector of Source to Interference Ratios (SIR)</p>
</dd>
<dt><strong>sar</strong><span class="classifier">np.ndarray, shape=(nsrc, nframes)</span></dt><dd><p>vector of Sources to Artifacts Ratios (SAR)</p>
</dd>
<dt><strong>perm</strong><span class="classifier">np.ndarray, shape=(nsrc, nframes)</span></dt><dd><p>vector containing the best ordering of estimated sources in
the mean SIR sense (estimated source number <code class="docutils literal notranslate"><span class="pre">perm[j]</span></code> corresponds to
true source number <code class="docutils literal notranslate"><span class="pre">j</span></code>).  Note: <code class="docutils literal notranslate"><span class="pre">perm</span></code> will be <code class="docutils literal notranslate"><span class="pre">range(nsrc)</span></code> for
all windows if <code class="docutils literal notranslate"><span class="pre">compute_permutation</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># reference_sources[n] should be an ndarray of samples of the</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># n&#39;th reference source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># estimated_sources[n] should be the same for the n&#39;th estimated</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">sdr</span><span class="p">,</span> <span class="n">sir</span><span class="p">,</span> <span class="n">sar</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">perm</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">separation</span><span class="o">.</span><span class="n">bss_eval_sources_framewise</span><span class="p">(</span>
<span class="go">         reference_sources,</span>
<span class="gp">... </span>     <span class="n">estimated_sources</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.separation.bss_eval_images">
<span class="sig-prename descclassname"><span class="pre">mir_eval.separation.</span></span><span class="sig-name descname"><span class="pre">bss_eval_images</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_sources</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_sources</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_permutation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.separation.bss_eval_images" title="Permalink to this definition">¶</a></dt>
<dd><p>Implementation of the bss_eval_images function from the
BSS_EVAL Matlab toolbox.</p>
<p>Ordering and measurement of the separation quality for estimated source
signals in terms of filtered true source, interference and artifacts.
This method also provides the ISR measure.</p>
<p>The decomposition allows a time-invariant filter distortion of length
512, as described in Section III.B of <a class="footnote-reference brackets" href="#vincent2006performance" id="id38">13</a>.</p>
<p>Passing <code class="docutils literal notranslate"><span class="pre">False</span></code> for <code class="docutils literal notranslate"><span class="pre">compute_permutation</span></code> will improve the computation
performance of the evaluation; however, it is not always appropriate and
is not the way that the BSS_EVAL Matlab toolbox computes bss_eval_images.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_sources</strong><span class="classifier">np.ndarray, shape=(nsrc, nsampl, nchan)</span></dt><dd><p>matrix containing true sources</p>
</dd>
<dt><strong>estimated_sources</strong><span class="classifier">np.ndarray, shape=(nsrc, nsampl, nchan)</span></dt><dd><p>matrix containing estimated sources</p>
</dd>
<dt><strong>compute_permutation</strong><span class="classifier">bool, optional</span></dt><dd><p>compute permutation of estimate/source combinations (True by default)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>sdr</strong><span class="classifier">np.ndarray, shape=(nsrc,)</span></dt><dd><p>vector of Signal to Distortion Ratios (SDR)</p>
</dd>
<dt><strong>isr</strong><span class="classifier">np.ndarray, shape=(nsrc,)</span></dt><dd><p>vector of source Image to Spatial distortion Ratios (ISR)</p>
</dd>
<dt><strong>sir</strong><span class="classifier">np.ndarray, shape=(nsrc,)</span></dt><dd><p>vector of Source to Interference Ratios (SIR)</p>
</dd>
<dt><strong>sar</strong><span class="classifier">np.ndarray, shape=(nsrc,)</span></dt><dd><p>vector of Sources to Artifacts Ratios (SAR)</p>
</dd>
<dt><strong>perm</strong><span class="classifier">np.ndarray, shape=(nsrc,)</span></dt><dd><p>vector containing the best ordering of estimated sources in
the mean SIR sense (estimated source number <code class="docutils literal notranslate"><span class="pre">perm[j]</span></code> corresponds to
true source number <code class="docutils literal notranslate"><span class="pre">j</span></code>).  Note: <code class="docutils literal notranslate"><span class="pre">perm</span></code> will be <code class="docutils literal notranslate"><span class="pre">(1,2,...,nsrc)</span></code>
if <code class="docutils literal notranslate"><span class="pre">compute_permutation</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id39"><span class="brackets">15</span></dt>
<dd><p>Emmanuel Vincent, Shoko Araki, Fabian J. Theis, Guido Nolte, Pau
Bofill, Hiroshi Sawada, Alexey Ozerov, B. Vikrham Gowreesunker, Dominik
Lutter and Ngoc Q.K. Duong, “The Signal Separation Evaluation Campaign
(2007-2010): Achievements and remaining challenges”, Signal Processing,
92, pp. 1928-1936, 2012.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># reference_sources[n] should be an ndarray of samples of the</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># n&#39;th reference source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># estimated_sources[n] should be the same for the n&#39;th estimated</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">sdr</span><span class="p">,</span> <span class="n">isr</span><span class="p">,</span> <span class="n">sir</span><span class="p">,</span> <span class="n">sar</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">perm</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">separation</span><span class="o">.</span><span class="n">bss_eval_images</span><span class="p">(</span><span class="n">reference_sources</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">estimated_sources</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.separation.bss_eval_images_framewise">
<span class="sig-prename descclassname"><span class="pre">mir_eval.separation.</span></span><span class="sig-name descname"><span class="pre">bss_eval_images_framewise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_sources</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_sources</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1323000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">661500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_permutation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.separation.bss_eval_images_framewise" title="Permalink to this definition">¶</a></dt>
<dd><p>Framewise computation of bss_eval_images</p>
<p>Please be aware that this function does not compute permutations (by
default) on the possible relations between <code class="docutils literal notranslate"><span class="pre">reference_sources</span></code> and
<code class="docutils literal notranslate"><span class="pre">estimated_sources</span></code> due to the dangers of a changing permutation.
Therefore (by default), it assumes that <code class="docutils literal notranslate"><span class="pre">reference_sources[i]</span></code>
corresponds to <code class="docutils literal notranslate"><span class="pre">estimated_sources[i]</span></code>. To enable computing permutations
please set <code class="docutils literal notranslate"><span class="pre">compute_permutation</span></code> to be <code class="docutils literal notranslate"><span class="pre">True</span></code> and check that the
returned <code class="docutils literal notranslate"><span class="pre">perm</span></code> is identical for all windows.</p>
<p>NOTE: if <code class="docutils literal notranslate"><span class="pre">reference_sources</span></code> and <code class="docutils literal notranslate"><span class="pre">estimated_sources</span></code> would be evaluated
using only a single window or are shorter than the window length, the
result of <code class="docutils literal notranslate"><span class="pre">bss_eval_images</span></code> called on <code class="docutils literal notranslate"><span class="pre">reference_sources</span></code> and
<code class="docutils literal notranslate"><span class="pre">estimated_sources</span></code> (with the <code class="docutils literal notranslate"><span class="pre">compute_permutation</span></code> parameter passed to
<code class="docutils literal notranslate"><span class="pre">bss_eval_images</span></code>) is returned</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_sources</strong><span class="classifier">np.ndarray, shape=(nsrc, nsampl, nchan)</span></dt><dd><p>matrix containing true sources (must have the same shape as
<code class="docutils literal notranslate"><span class="pre">estimated_sources</span></code>)</p>
</dd>
<dt><strong>estimated_sources</strong><span class="classifier">np.ndarray, shape=(nsrc, nsampl, nchan)</span></dt><dd><p>matrix containing estimated sources (must have the same shape as
<code class="docutils literal notranslate"><span class="pre">reference_sources</span></code>)</p>
</dd>
<dt><strong>window</strong><span class="classifier">int</span></dt><dd><p>Window length for framewise evaluation</p>
</dd>
<dt><strong>hop</strong><span class="classifier">int</span></dt><dd><p>Hop size for framewise evaluation</p>
</dd>
<dt><strong>compute_permutation</strong><span class="classifier">bool, optional</span></dt><dd><p>compute permutation of estimate/source combinations for all windows
(False by default)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>sdr</strong><span class="classifier">np.ndarray, shape=(nsrc, nframes)</span></dt><dd><p>vector of Signal to Distortion Ratios (SDR)</p>
</dd>
<dt><strong>isr</strong><span class="classifier">np.ndarray, shape=(nsrc, nframes)</span></dt><dd><p>vector of source Image to Spatial distortion Ratios (ISR)</p>
</dd>
<dt><strong>sir</strong><span class="classifier">np.ndarray, shape=(nsrc, nframes)</span></dt><dd><p>vector of Source to Interference Ratios (SIR)</p>
</dd>
<dt><strong>sar</strong><span class="classifier">np.ndarray, shape=(nsrc, nframes)</span></dt><dd><p>vector of Sources to Artifacts Ratios (SAR)</p>
</dd>
<dt><strong>perm</strong><span class="classifier">np.ndarray, shape=(nsrc, nframes)</span></dt><dd><p>vector containing the best ordering of estimated sources in
the mean SIR sense (estimated source number perm[j] corresponds to
true source number j)
Note: perm will be range(nsrc) for all windows if compute_permutation
is False</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># reference_sources[n] should be an ndarray of samples of the</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># n&#39;th reference source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># estimated_sources[n] should be the same for the n&#39;th estimated</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">sdr</span><span class="p">,</span> <span class="n">isr</span><span class="p">,</span> <span class="n">sir</span><span class="p">,</span> <span class="n">sar</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">perm</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">separation</span><span class="o">.</span><span class="n">bss_eval_images_framewise</span><span class="p">(</span>
<span class="go">         reference_sources,</span>
<span class="gp">... </span>     <span class="n">estimated_sources</span><span class="p">,</span>
<span class="go">         window,</span>
<span class="go">....     hop)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.separation.evaluate">
<span class="sig-prename descclassname"><span class="pre">mir_eval.separation.</span></span><span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_sources</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_sources</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.separation.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all metrics for the given reference and estimated signals.</p>
<p>NOTE: This will always compute <a class="reference internal" href="#mir_eval.separation.bss_eval_images" title="mir_eval.separation.bss_eval_images"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.separation.bss_eval_images()</span></code></a>
for any valid input and will additionally compute
<a class="reference internal" href="#mir_eval.separation.bss_eval_sources" title="mir_eval.separation.bss_eval_sources"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.separation.bss_eval_sources()</span></code></a> for valid input with fewer
than 3 dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_sources</strong><span class="classifier">np.ndarray, shape=(nsrc, nsampl[, nchan])</span></dt><dd><p>matrix containing true sources</p>
</dd>
<dt><strong>estimated_sources</strong><span class="classifier">np.ndarray, shape=(nsrc, nsampl[, nchan])</span></dt><dd><p>matrix containing estimated sources</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scores</strong><span class="classifier">dict</span></dt><dd><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># reference_sources[n] should be an ndarray of samples of the</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># n&#39;th reference source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># estimated_sources[n] should be the same for the n&#39;th estimated source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">separation</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">reference_sources</span><span class="p">,</span>
<span class="gp">... </span>                                      <span class="n">estimated_sources</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="module-mir_eval.tempo">
<span id="mir-eval-tempo"></span><h3><a class="reference internal" href="#module-mir_eval.tempo" title="mir_eval.tempo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.tempo</span></code></a><a class="headerlink" href="#module-mir_eval.tempo" title="Permalink to this headline">¶</a></h3>
<p>The goal of a tempo estimation algorithm is to automatically detect the tempo
of a piece of music, measured in beats per minute (BPM).</p>
<p>See <a class="reference external" href="http://www.music-ir.org/mirex/wiki/2014:Audio_Tempo_Estimation">http://www.music-ir.org/mirex/wiki/2014:Audio_Tempo_Estimation</a> for a
description of the task and evaluation criteria.</p>
<section id="id40">
<h4>Conventions<a class="headerlink" href="#id40" title="Permalink to this headline">¶</a></h4>
<p>Reference and estimated tempi should be positive, and provided in ascending
order as a numpy array of length 2.</p>
<p>The weighting value from the reference must be a float in the range [0, 1].</p>
</section>
<section id="id41">
<h4>Metrics<a class="headerlink" href="#id41" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><a class="reference internal" href="#mir_eval.tempo.detection" title="mir_eval.tempo.detection"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.tempo.detection()</span></code></a>: Relative error, hits, and weighted
precision of tempo estimation.</p></li>
</ul>
<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.tempo.validate_tempi">
<span class="sig-prename descclassname"><span class="pre">mir_eval.tempo.</span></span><span class="sig-name descname"><span class="pre">validate_tempi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tempi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.tempo.validate_tempi" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that there are two non-negative tempi.
For a reference value, at least one tempo has to be greater than zero.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tempi</strong><span class="classifier">np.ndarray</span></dt><dd><p>length-2 array of tempo, in bpm</p>
</dd>
<dt><strong>reference</strong><span class="classifier">bool</span></dt><dd><p>indicates a reference value</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.tempo.validate">
<span class="sig-prename descclassname"><span class="pre">mir_eval.tempo.</span></span><span class="sig-name descname"><span class="pre">validate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_tempi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference_weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_tempi</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.tempo.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a metric look like valid tempo
annotations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_tempi</strong><span class="classifier">np.ndarray</span></dt><dd><p>reference tempo values, in bpm</p>
</dd>
<dt><strong>reference_weight</strong><span class="classifier">float</span></dt><dd><p>perceptual weight of slow vs fast in reference</p>
</dd>
<dt><strong>estimated_tempi</strong><span class="classifier">np.ndarray</span></dt><dd><p>estimated tempo values, in bpm</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.tempo.detection">
<span class="sig-prename descclassname"><span class="pre">mir_eval.tempo.</span></span><span class="sig-name descname"><span class="pre">detection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_tempi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference_weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_tempi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.08</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.tempo.detection" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the tempo detection accuracy metric.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_tempi</strong><span class="classifier">np.ndarray, shape=(2,)</span></dt><dd><p>Two non-negative reference tempi</p>
</dd>
<dt><strong>reference_weight</strong><span class="classifier">float &gt; 0</span></dt><dd><p>The relative strength of <code class="docutils literal notranslate"><span class="pre">reference_tempi[0]</span></code> vs
<code class="docutils literal notranslate"><span class="pre">reference_tempi[1]</span></code>.</p>
</dd>
<dt><strong>estimated_tempi</strong><span class="classifier">np.ndarray, shape=(2,)</span></dt><dd><p>Two non-negative estimated tempi.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float in [0, 1]:</span></dt><dd><p>The maximum allowable deviation from a reference tempo to
count as a hit.
<code class="docutils literal notranslate"><span class="pre">|est_t</span> <span class="pre">-</span> <span class="pre">ref_t|</span> <span class="pre">&lt;=</span> <span class="pre">tol</span> <span class="pre">*</span> <span class="pre">ref_t</span></code>
(Default value = 0.08)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>p_score</strong><span class="classifier">float in [0, 1]</span></dt><dd><p>Weighted average of recalls:
<code class="docutils literal notranslate"><span class="pre">reference_weight</span> <span class="pre">*</span> <span class="pre">hits[0]</span> <span class="pre">+</span> <span class="pre">(1</span> <span class="pre">-</span> <span class="pre">reference_weight)</span> <span class="pre">*</span> <span class="pre">hits[1]</span></code></p>
</dd>
<dt><strong>one_correct</strong><span class="classifier">bool</span></dt><dd><p>True if at least one reference tempo was correctly estimated</p>
</dd>
<dt><strong>both_correct</strong><span class="classifier">bool</span></dt><dd><p>True if both reference tempi were correctly estimated</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl>
<dt>ValueError</dt><dd><p>If the input tempi are ill-formed</p>
<p>If the reference weight is not in the range [0, 1]</p>
<p>If <code class="docutils literal notranslate"><span class="pre">tol</span> <span class="pre">&lt;</span> <span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">tol</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.tempo.evaluate">
<span class="sig-prename descclassname"><span class="pre">mir_eval.tempo.</span></span><span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_tempi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference_weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_tempi</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.tempo.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all metrics for the given reference and estimated annotations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_tempi</strong><span class="classifier">np.ndarray, shape=(2,)</span></dt><dd><p>Two non-negative reference tempi</p>
</dd>
<dt><strong>reference_weight</strong><span class="classifier">float &gt; 0</span></dt><dd><p>The relative strength of <code class="docutils literal notranslate"><span class="pre">reference_tempi[0]</span></code> vs
<code class="docutils literal notranslate"><span class="pre">reference_tempi[1]</span></code>.</p>
</dd>
<dt><strong>estimated_tempi</strong><span class="classifier">np.ndarray, shape=(2,)</span></dt><dd><p>Two non-negative estimated tempi.</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scores</strong><span class="classifier">dict</span></dt><dd><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="module-mir_eval.transcription">
<span id="mir-eval-transcription"></span><h3><a class="reference internal" href="#module-mir_eval.transcription" title="mir_eval.transcription"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.transcription</span></code></a><a class="headerlink" href="#module-mir_eval.transcription" title="Permalink to this headline">¶</a></h3>
<p>The aim of a transcription algorithm is to produce a symbolic representation of
a recorded piece of music in the form of a set of discrete notes. There are
different ways to represent notes symbolically. Here we use the piano-roll
convention, meaning each note has a start time, a duration (or end time), and
a single, constant, pitch value. Pitch values can be quantized (e.g. to a
semitone grid tuned to 440 Hz), but do not have to be. Also, the transcription
can contain the notes of a single instrument or voice (for example the melody),
or the notes of all instruments/voices in the recording. This module is
instrument agnostic: all notes in the estimate are compared against all notes
in the reference.</p>
<p>There are many metrics for evaluating transcription algorithms. Here we limit
ourselves to the most simple and commonly used: given two sets of notes, we
count how many estimated notes match the reference, and how many do not. Based
on these counts we compute the precision, recall, f-measure and overlap ratio
of the estimate given the reference. The default criteria for considering two
notes to be a match are adopted from the <a class="reference external" href="http://www.music-ir.org/mirex/wiki/2015:Multiple_Fundamental_Frequency_Estimation_%26_Tracking_Results_-_MIREX_Dataset#Task_2:Note_Tracking_.28NT.29">MIREX Multiple fundamental frequency
estimation and tracking, Note Tracking subtask (task 2)</a>:</p>
<p>“This subtask is evaluated in two different ways. In the first setup , a
returned note is assumed correct if its onset is within +-50ms of a reference
note and its F0 is within +- quarter tone of the corresponding reference note,
ignoring the returned offset values. In the second setup, on top of the above
requirements, a correct returned note is required to have an offset value
within 20% of the reference note’s duration around the reference note’s
offset, or within 50ms whichever is larger.”</p>
<p>In short, we compute precision, recall, f-measure and overlap ratio, once
without taking offsets into account, and the second time with.</p>
<p>For further details see Salamon, 2013 (page 186), and references therein:</p>
<blockquote>
<div><p>Salamon, J. (2013). Melody Extraction from Polyphonic Music Signals.
Ph.D. thesis, Universitat Pompeu Fabra, Barcelona, Spain, 2013.</p>
</div></blockquote>
<p>IMPORTANT NOTE: the evaluation code in <code class="docutils literal notranslate"><span class="pre">mir_eval</span></code> contains several important
differences with respect to the code used in MIREX 2015 for the Note Tracking
subtask on the Su dataset (henceforth “MIREX”):</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mir_eval</span></code> uses bipartite graph matching to find the optimal pairing of
reference notes to estimated notes. MIREX uses a greedy matching algorithm,
which can produce sub-optimal note matching. This will result in
<code class="docutils literal notranslate"><span class="pre">mir_eval</span></code>’s metrics being slightly higher compared to MIREX.</p></li>
<li><p>MIREX rounds down the onset and offset times of each note to 2 decimal
points using <code class="docutils literal notranslate"><span class="pre">new_time</span> <span class="pre">=</span> <span class="pre">0.01</span> <span class="pre">*</span> <span class="pre">floor(time*100)</span></code>. <code class="docutils literal notranslate"><span class="pre">mir_eval</span></code> rounds down
the note onset and offset times to 4 decinal points. This will bring our
metrics down a notch compared to the MIREX results.</p></li>
<li><p>In the MIREX wiki, the criterion for matching offsets is that they must be
within <code class="docutils literal notranslate"><span class="pre">0.2</span> <span class="pre">*</span> <span class="pre">ref_duration</span></code> <strong>or 0.05 seconds from each other, whichever
is greater</strong> (i.e. <code class="docutils literal notranslate"><span class="pre">offset_dif</span> <span class="pre">&lt;=</span> <span class="pre">max(0.2</span> <span class="pre">*</span> <span class="pre">ref_duration,</span> <span class="pre">0.05)</span></code>. The
MIREX code however only uses a threshold of <code class="docutils literal notranslate"><span class="pre">0.2</span> <span class="pre">*</span> <span class="pre">ref_duration</span></code>, without
the 0.05 second minimum. Since <code class="docutils literal notranslate"><span class="pre">mir_eval</span></code> does include this minimum, it
might produce slightly higher results compared to MIREX.</p></li>
</ol>
<p>This means that differences 1 and 3 bring <code class="docutils literal notranslate"><span class="pre">mir_eval</span></code>’s metrics up compared to
MIREX, whilst 2 brings them down. Based on internal testing, overall the effect
of these three differences is that the Precision, Recall and F-measure returned
by <code class="docutils literal notranslate"><span class="pre">mir_eval</span></code> will be higher compared to MIREX by about 1%-2%.</p>
<p>Finally, note that different evaluation scripts have been used for the Multi-F0
Note Tracking task in MIREX over the years. In particular, some scripts used
<code class="docutils literal notranslate"><span class="pre">&lt;</span></code> for matching onsets, offsets, and pitch values, whilst the others used
<code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> for these checks. <code class="docutils literal notranslate"><span class="pre">mir_eval</span></code> provides both options: by default the
latter (<code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>) is used, but you can set <code class="docutils literal notranslate"><span class="pre">strict=True</span></code> when calling
<a class="reference internal" href="#mir_eval.transcription.precision_recall_f1_overlap" title="mir_eval.transcription.precision_recall_f1_overlap"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.transcription.precision_recall_f1_overlap()</span></code></a> in which case
<code class="docutils literal notranslate"><span class="pre">&lt;</span></code> will be used. The default value (<code class="docutils literal notranslate"><span class="pre">strict=False</span></code>) is the same as that
used in MIREX 2015 for the Note Tracking subtask on the Su dataset.</p>
<section id="id42">
<h4>Conventions<a class="headerlink" href="#id42" title="Permalink to this headline">¶</a></h4>
<p>Notes should be provided in the form of an interval array and a pitch array.
The interval array contains two columns, one for note onsets and the second
for note offsets (each row represents a single note). The pitch array contains
one column with the corresponding note pitch values (one value per note),
represented by their fundamental frequency (f0) in Hertz.</p>
</section>
<section id="id43">
<h4>Metrics<a class="headerlink" href="#id43" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><a class="reference internal" href="#mir_eval.transcription.precision_recall_f1_overlap" title="mir_eval.transcription.precision_recall_f1_overlap"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.transcription.precision_recall_f1_overlap()</span></code></a>: The precision,
recall, F-measure, and Average Overlap Ratio of the note transcription,
where an estimated note is considered correct if its pitch, onset and
(optionally) offset are sufficiently close to a reference note.</p></li>
<li><p><a class="reference internal" href="#mir_eval.transcription.onset_precision_recall_f1" title="mir_eval.transcription.onset_precision_recall_f1"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.transcription.onset_precision_recall_f1()</span></code></a>: The precision,
recall and F-measure of the note transcription, where an estimated note is
considered correct if its onset is sufficiently close to a reference note’s
onset. That is, these metrics are computed taking only note onsets into
account, meaning two notes could be matched even if they have very different
pitch values.</p></li>
<li><p><a class="reference internal" href="#mir_eval.transcription.offset_precision_recall_f1" title="mir_eval.transcription.offset_precision_recall_f1"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.transcription.offset_precision_recall_f1()</span></code></a>: The precision,
recall and F-measure of the note transcription, where an estimated note is
considered correct if its offset is sufficiently close to a reference note’s
offset. That is, these metrics are computed taking only note offsets into
account, meaning two notes could be matched even if they have very different
pitch values.</p></li>
</ul>
<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.transcription.validate">
<span class="sig-prename descclassname"><span class="pre">mir_eval.transcription.</span></span><span class="sig-name descname"><span class="pre">validate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_pitches</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_pitches</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.transcription.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a metric look like time intervals
and a pitch list, and throws helpful errors if not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ref_intervals</strong><span class="classifier">np.ndarray, shape=(n,2)</span></dt><dd><p>Array of reference notes time intervals (onset and offset times)</p>
</dd>
<dt><strong>ref_pitches</strong><span class="classifier">np.ndarray, shape=(n,)</span></dt><dd><p>Array of reference pitch values in Hertz</p>
</dd>
<dt><strong>est_intervals</strong><span class="classifier">np.ndarray, shape=(m,2)</span></dt><dd><p>Array of estimated notes time intervals (onset and offset times)</p>
</dd>
<dt><strong>est_pitches</strong><span class="classifier">np.ndarray, shape=(m,)</span></dt><dd><p>Array of estimated pitch values in Hertz</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.transcription.validate_intervals">
<span class="sig-prename descclassname"><span class="pre">mir_eval.transcription.</span></span><span class="sig-name descname"><span class="pre">validate_intervals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_intervals</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.transcription.validate_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a metric look like time intervals,
and throws helpful errors if not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ref_intervals</strong><span class="classifier">np.ndarray, shape=(n,2)</span></dt><dd><p>Array of reference notes time intervals (onset and offset times)</p>
</dd>
<dt><strong>est_intervals</strong><span class="classifier">np.ndarray, shape=(m,2)</span></dt><dd><p>Array of estimated notes time intervals (onset and offset times)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.transcription.match_note_offsets">
<span class="sig-prename descclassname"><span class="pre">mir_eval.transcription.</span></span><span class="sig-name descname"><span class="pre">match_note_offsets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset_ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset_min_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.transcription.match_note_offsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a maximum matching between reference and estimated notes,
only taking note offsets into account.</p>
<p>Given two note sequences represented by <code class="docutils literal notranslate"><span class="pre">ref_intervals</span></code> and
<code class="docutils literal notranslate"><span class="pre">est_intervals</span></code> (see <a class="reference internal" href="#mir_eval.io.load_valued_intervals" title="mir_eval.io.load_valued_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_valued_intervals()</span></code></a>), we seek
the largest set of correspondences <code class="docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">j)</span></code> such that the offset of
reference note <code class="docutils literal notranslate"><span class="pre">i</span></code> has to be within <code class="docutils literal notranslate"><span class="pre">offset_tolerance</span></code> of the offset of
estimated note <code class="docutils literal notranslate"><span class="pre">j</span></code>, where <code class="docutils literal notranslate"><span class="pre">offset_tolerance</span></code> is equal to
<code class="docutils literal notranslate"><span class="pre">offset_ratio</span></code> times the reference note’s duration, i.e.  <code class="docutils literal notranslate"><span class="pre">offset_ratio</span>
<span class="pre">*</span> <span class="pre">ref_duration[i]</span></code> where <code class="docutils literal notranslate"><span class="pre">ref_duration[i]</span> <span class="pre">=</span> <span class="pre">ref_intervals[i,</span> <span class="pre">1]</span> <span class="pre">-</span>
<span class="pre">ref_intervals[i,</span> <span class="pre">0]</span></code>. If the resulting <code class="docutils literal notranslate"><span class="pre">offset_tolerance</span></code> is less than
<code class="docutils literal notranslate"><span class="pre">offset_min_tolerance</span></code> (50 ms by default) then <code class="docutils literal notranslate"><span class="pre">offset_min_tolerance</span></code>
is used instead.</p>
<p>Every reference note is matched against at most one estimated note.</p>
<p>Note there are separate functions <a class="reference internal" href="#mir_eval.transcription.match_note_onsets" title="mir_eval.transcription.match_note_onsets"><code class="xref py py-func docutils literal notranslate"><span class="pre">match_note_onsets()</span></code></a> and
<a class="reference internal" href="#mir_eval.transcription.match_notes" title="mir_eval.transcription.match_notes"><code class="xref py py-func docutils literal notranslate"><span class="pre">match_notes()</span></code></a> for matching notes based on onsets only or based on
onset, offset, and pitch, respectively. This is because the rules for
matching note onsets and matching note offsets are different.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ref_intervals</strong><span class="classifier">np.ndarray, shape=(n,2)</span></dt><dd><p>Array of reference notes time intervals (onset and offset times)</p>
</dd>
<dt><strong>est_intervals</strong><span class="classifier">np.ndarray, shape=(m,2)</span></dt><dd><p>Array of estimated notes time intervals (onset and offset times)</p>
</dd>
<dt><strong>offset_ratio</strong><span class="classifier">float &gt; 0</span></dt><dd><p>The ratio of the reference note’s duration used to define the
<code class="docutils literal notranslate"><span class="pre">offset_tolerance</span></code>. Default is 0.2 (20%), meaning the
<code class="docutils literal notranslate"><span class="pre">offset_tolerance</span></code> will equal the <code class="docutils literal notranslate"><span class="pre">ref_duration</span> <span class="pre">*</span> <span class="pre">0.2</span></code>, or 0.05 (50
ms), whichever is greater.</p>
</dd>
<dt><strong>offset_min_tolerance</strong><span class="classifier">float &gt; 0</span></dt><dd><p>The minimum tolerance for offset matching. See <code class="docutils literal notranslate"><span class="pre">offset_ratio</span></code>
description for an explanation of how the offset tolerance is
determined.</p>
</dd>
<dt><strong>strict</strong><span class="classifier">bool</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">strict=False</span></code> (the default), threshold checks for offset
matching are performed using <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> (less than or equal). If
<code class="docutils literal notranslate"><span class="pre">strict=True</span></code>, the threshold checks are performed using <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> (less
than).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>matching</strong><span class="classifier">list of tuples</span></dt><dd><p>A list of matched reference and estimated notes.
<code class="docutils literal notranslate"><span class="pre">matching[i]</span> <span class="pre">==</span> <span class="pre">(i,</span> <span class="pre">j)</span></code> where reference note <code class="docutils literal notranslate"><span class="pre">i</span></code> matches estimated
note <code class="docutils literal notranslate"><span class="pre">j</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.transcription.match_note_onsets">
<span class="sig-prename descclassname"><span class="pre">mir_eval.transcription.</span></span><span class="sig-name descname"><span class="pre">match_note_onsets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">onset_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.transcription.match_note_onsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a maximum matching between reference and estimated notes,
only taking note onsets into account.</p>
<p>Given two note sequences represented by <code class="docutils literal notranslate"><span class="pre">ref_intervals</span></code> and
<code class="docutils literal notranslate"><span class="pre">est_intervals</span></code> (see <a class="reference internal" href="#mir_eval.io.load_valued_intervals" title="mir_eval.io.load_valued_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_valued_intervals()</span></code></a>), we see
the largest set of correspondences <code class="docutils literal notranslate"><span class="pre">(i,j)</span></code> such that the onset of
reference note <code class="docutils literal notranslate"><span class="pre">i</span></code> is within <code class="docutils literal notranslate"><span class="pre">onset_tolerance</span></code> of the onset of
estimated note <code class="docutils literal notranslate"><span class="pre">j</span></code>.</p>
<p>Every reference note is matched against at most one estimated note.</p>
<p>Note there are separate functions <a class="reference internal" href="#mir_eval.transcription.match_note_offsets" title="mir_eval.transcription.match_note_offsets"><code class="xref py py-func docutils literal notranslate"><span class="pre">match_note_offsets()</span></code></a> and
<a class="reference internal" href="#mir_eval.transcription.match_notes" title="mir_eval.transcription.match_notes"><code class="xref py py-func docutils literal notranslate"><span class="pre">match_notes()</span></code></a> for matching notes based on offsets only or based on
onset, offset, and pitch, respectively. This is because the rules for
matching note onsets and matching note offsets are different.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ref_intervals</strong><span class="classifier">np.ndarray, shape=(n,2)</span></dt><dd><p>Array of reference notes time intervals (onset and offset times)</p>
</dd>
<dt><strong>est_intervals</strong><span class="classifier">np.ndarray, shape=(m,2)</span></dt><dd><p>Array of estimated notes time intervals (onset and offset times)</p>
</dd>
<dt><strong>onset_tolerance</strong><span class="classifier">float &gt; 0</span></dt><dd><p>The tolerance for an estimated note’s onset deviating from the
reference note’s onset, in seconds. Default is 0.05 (50 ms).</p>
</dd>
<dt><strong>strict</strong><span class="classifier">bool</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">strict=False</span></code> (the default), threshold checks for onset matching
are performed using <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> (less than or equal). If <code class="docutils literal notranslate"><span class="pre">strict=True</span></code>,
the threshold checks are performed using <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> (less than).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>matching</strong><span class="classifier">list of tuples</span></dt><dd><p>A list of matched reference and estimated notes.
<code class="docutils literal notranslate"><span class="pre">matching[i]</span> <span class="pre">==</span> <span class="pre">(i,</span> <span class="pre">j)</span></code> where reference note <code class="docutils literal notranslate"><span class="pre">i</span></code> matches estimated
note <code class="docutils literal notranslate"><span class="pre">j</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.transcription.match_notes">
<span class="sig-prename descclassname"><span class="pre">mir_eval.transcription.</span></span><span class="sig-name descname"><span class="pre">match_notes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_pitches</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_pitches</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">onset_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pitch_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset_ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset_min_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.transcription.match_notes" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a maximum matching between reference and estimated notes,
subject to onset, pitch and (optionally) offset constraints.</p>
<p>Given two note sequences represented by <code class="docutils literal notranslate"><span class="pre">ref_intervals</span></code>, <code class="docutils literal notranslate"><span class="pre">ref_pitches</span></code>,
<code class="docutils literal notranslate"><span class="pre">est_intervals</span></code> and <code class="docutils literal notranslate"><span class="pre">est_pitches</span></code>
(see <a class="reference internal" href="#mir_eval.io.load_valued_intervals" title="mir_eval.io.load_valued_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_valued_intervals()</span></code></a>), we seek the largest set
of correspondences <code class="docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">j)</span></code> such that:</p>
<ol class="arabic simple">
<li><p>The onset of reference note <code class="docutils literal notranslate"><span class="pre">i</span></code> is within <code class="docutils literal notranslate"><span class="pre">onset_tolerance</span></code> of the
onset of estimated note <code class="docutils literal notranslate"><span class="pre">j</span></code>.</p></li>
<li><p>The pitch of reference note <code class="docutils literal notranslate"><span class="pre">i</span></code> is within <code class="docutils literal notranslate"><span class="pre">pitch_tolerance</span></code> of the
pitch of estimated note <code class="docutils literal notranslate"><span class="pre">j</span></code>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">offset_ratio</span></code> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, the offset of reference note <code class="docutils literal notranslate"><span class="pre">i</span></code>
has to be within <code class="docutils literal notranslate"><span class="pre">offset_tolerance</span></code> of the offset of estimated note
<code class="docutils literal notranslate"><span class="pre">j</span></code>, where <code class="docutils literal notranslate"><span class="pre">offset_tolerance</span></code> is equal to <code class="docutils literal notranslate"><span class="pre">offset_ratio</span></code> times the
reference note’s duration, i.e. <code class="docutils literal notranslate"><span class="pre">offset_ratio</span> <span class="pre">*</span> <span class="pre">ref_duration[i]</span></code> where
<code class="docutils literal notranslate"><span class="pre">ref_duration[i]</span> <span class="pre">=</span> <span class="pre">ref_intervals[i,</span> <span class="pre">1]</span> <span class="pre">-</span> <span class="pre">ref_intervals[i,</span> <span class="pre">0]</span></code>.  If the
resulting <code class="docutils literal notranslate"><span class="pre">offset_tolerance</span></code> is less than 0.05 (50 ms), 0.05 is used
instead.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">offset_ratio</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, note offsets are ignored, and only
criteria 1 and 2 are taken into consideration.</p></li>
</ol>
<p>Every reference note is matched against at most one estimated note.</p>
<p>This is useful for computing precision/recall metrics for note
transcription.</p>
<p>Note there are separate functions <a class="reference internal" href="#mir_eval.transcription.match_note_onsets" title="mir_eval.transcription.match_note_onsets"><code class="xref py py-func docutils literal notranslate"><span class="pre">match_note_onsets()</span></code></a> and
<a class="reference internal" href="#mir_eval.transcription.match_note_offsets" title="mir_eval.transcription.match_note_offsets"><code class="xref py py-func docutils literal notranslate"><span class="pre">match_note_offsets()</span></code></a> for matching notes based on onsets only or based
on offsets only, respectively.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ref_intervals</strong><span class="classifier">np.ndarray, shape=(n,2)</span></dt><dd><p>Array of reference notes time intervals (onset and offset times)</p>
</dd>
<dt><strong>ref_pitches</strong><span class="classifier">np.ndarray, shape=(n,)</span></dt><dd><p>Array of reference pitch values in Hertz</p>
</dd>
<dt><strong>est_intervals</strong><span class="classifier">np.ndarray, shape=(m,2)</span></dt><dd><p>Array of estimated notes time intervals (onset and offset times)</p>
</dd>
<dt><strong>est_pitches</strong><span class="classifier">np.ndarray, shape=(m,)</span></dt><dd><p>Array of estimated pitch values in Hertz</p>
</dd>
<dt><strong>onset_tolerance</strong><span class="classifier">float &gt; 0</span></dt><dd><p>The tolerance for an estimated note’s onset deviating from the
reference note’s onset, in seconds. Default is 0.05 (50 ms).</p>
</dd>
<dt><strong>pitch_tolerance</strong><span class="classifier">float &gt; 0</span></dt><dd><p>The tolerance for an estimated note’s pitch deviating from the
reference note’s pitch, in cents. Default is 50.0 (50 cents).</p>
</dd>
<dt><strong>offset_ratio</strong><span class="classifier">float &gt; 0 or None</span></dt><dd><p>The ratio of the reference note’s duration used to define the
offset_tolerance. Default is 0.2 (20%), meaning the
<code class="docutils literal notranslate"><span class="pre">offset_tolerance</span></code> will equal the <code class="docutils literal notranslate"><span class="pre">ref_duration</span> <span class="pre">*</span> <span class="pre">0.2</span></code>, or 0.05 (50
ms), whichever is greater. If <code class="docutils literal notranslate"><span class="pre">offset_ratio</span></code> is set to <code class="docutils literal notranslate"><span class="pre">None</span></code>,
offsets are ignored in the matching.</p>
</dd>
<dt><strong>offset_min_tolerance</strong><span class="classifier">float &gt; 0</span></dt><dd><p>The minimum tolerance for offset matching. See offset_ratio description
for an explanation of how the offset tolerance is determined. Note:
this parameter only influences the results if <code class="docutils literal notranslate"><span class="pre">offset_ratio</span></code> is not
<code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
<dt><strong>strict</strong><span class="classifier">bool</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">strict=False</span></code> (the default), threshold checks for onset, offset,
and pitch matching are performed using <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> (less than or equal). If
<code class="docutils literal notranslate"><span class="pre">strict=True</span></code>, the threshold checks are performed using <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> (less
than).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>matching</strong><span class="classifier">list of tuples</span></dt><dd><p>A list of matched reference and estimated notes.
<code class="docutils literal notranslate"><span class="pre">matching[i]</span> <span class="pre">==</span> <span class="pre">(i,</span> <span class="pre">j)</span></code> where reference note <code class="docutils literal notranslate"><span class="pre">i</span></code> matches estimated
note <code class="docutils literal notranslate"><span class="pre">j</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.transcription.precision_recall_f1_overlap">
<span class="sig-prename descclassname"><span class="pre">mir_eval.transcription.</span></span><span class="sig-name descname"><span class="pre">precision_recall_f1_overlap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_pitches</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_pitches</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">onset_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pitch_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset_ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset_min_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.transcription.precision_recall_f1_overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Precision, Recall and F-measure of correct vs incorrectly
transcribed notes, and the Average Overlap Ratio for correctly transcribed
notes (see <a class="reference internal" href="#mir_eval.transcription.average_overlap_ratio" title="mir_eval.transcription.average_overlap_ratio"><code class="xref py py-func docutils literal notranslate"><span class="pre">average_overlap_ratio()</span></code></a>). “Correctness” is determined
based on note onset, pitch and (optionally) offset: an estimated note is
assumed correct if its onset is within +-50ms of a reference note and its
pitch (F0) is within +- quarter tone (50 cents) of the corresponding
reference note. If <code class="docutils literal notranslate"><span class="pre">offset_ratio</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, note offsets are ignored
in the comparison. Otherwise, on top of the above requirements, a correct
returned note is required to have an offset value within 20% (by default,
adjustable via the <code class="docutils literal notranslate"><span class="pre">offset_ratio</span></code> parameter) of the reference note’s
duration around the reference note’s offset, or within
<code class="docutils literal notranslate"><span class="pre">offset_min_tolerance</span></code> (50 ms by default), whichever is larger.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ref_intervals</strong><span class="classifier">np.ndarray, shape=(n,2)</span></dt><dd><p>Array of reference notes time intervals (onset and offset times)</p>
</dd>
<dt><strong>ref_pitches</strong><span class="classifier">np.ndarray, shape=(n,)</span></dt><dd><p>Array of reference pitch values in Hertz</p>
</dd>
<dt><strong>est_intervals</strong><span class="classifier">np.ndarray, shape=(m,2)</span></dt><dd><p>Array of estimated notes time intervals (onset and offset times)</p>
</dd>
<dt><strong>est_pitches</strong><span class="classifier">np.ndarray, shape=(m,)</span></dt><dd><p>Array of estimated pitch values in Hertz</p>
</dd>
<dt><strong>onset_tolerance</strong><span class="classifier">float &gt; 0</span></dt><dd><p>The tolerance for an estimated note’s onset deviating from the
reference note’s onset, in seconds. Default is 0.05 (50 ms).</p>
</dd>
<dt><strong>pitch_tolerance</strong><span class="classifier">float &gt; 0</span></dt><dd><p>The tolerance for an estimated note’s pitch deviating from the
reference note’s pitch, in cents. Default is 50.0 (50 cents).</p>
</dd>
<dt><strong>offset_ratio</strong><span class="classifier">float &gt; 0 or None</span></dt><dd><p>The ratio of the reference note’s duration used to define the
offset_tolerance. Default is 0.2 (20%), meaning the
<code class="docutils literal notranslate"><span class="pre">offset_tolerance</span></code> will equal the <code class="docutils literal notranslate"><span class="pre">ref_duration</span> <span class="pre">*</span> <span class="pre">0.2</span></code>, or
<code class="docutils literal notranslate"><span class="pre">offset_min_tolerance</span></code> (0.05 by default, i.e. 50 ms), whichever is
greater. If <code class="docutils literal notranslate"><span class="pre">offset_ratio</span></code> is set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, offsets are ignored in
the evaluation.</p>
</dd>
<dt><strong>offset_min_tolerance</strong><span class="classifier">float &gt; 0</span></dt><dd><p>The minimum tolerance for offset matching. See <code class="docutils literal notranslate"><span class="pre">offset_ratio</span></code>
description for an explanation of how the offset tolerance is
determined. Note: this parameter only influences the results if
<code class="docutils literal notranslate"><span class="pre">offset_ratio</span></code> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
<dt><strong>strict</strong><span class="classifier">bool</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">strict=False</span></code> (the default), threshold checks for onset, offset,
and pitch matching are performed using <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> (less than or equal). If
<code class="docutils literal notranslate"><span class="pre">strict=True</span></code>, the threshold checks are performed using <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> (less
than).</p>
</dd>
<dt><strong>beta</strong><span class="classifier">float &gt; 0</span></dt><dd><p>Weighting factor for f-measure (default value = 1.0).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>precision</strong><span class="classifier">float</span></dt><dd><p>The computed precision score</p>
</dd>
<dt><strong>recall</strong><span class="classifier">float</span></dt><dd><p>The computed recall score</p>
</dd>
<dt><strong>f_measure</strong><span class="classifier">float</span></dt><dd><p>The computed F-measure score</p>
</dd>
<dt><strong>avg_overlap_ratio</strong><span class="classifier">float</span></dt><dd><p>The computed Average Overlap Ratio score</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_pitches</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_valued_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_pitches</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_valued_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">precision</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">recall</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">f_measure</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">precision_recall_f1_overlap</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_pitches</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_pitches</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">precision_no_offset</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">recall_no_offset</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">f_measure_no_offset</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span>
<span class="gp">... </span>     <span class="n">mir_eval</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">precision_recall_f1_overlap</span><span class="p">(</span>
<span class="gp">... </span>         <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_pitches</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_pitches</span><span class="p">,</span>
<span class="gp">... </span>         <span class="n">offset_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.transcription.average_overlap_ratio">
<span class="sig-prename descclassname"><span class="pre">mir_eval.transcription.</span></span><span class="sig-name descname"><span class="pre">average_overlap_ratio</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matching</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.transcription.average_overlap_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Average Overlap Ratio between a reference and estimated
note transcription. Given a reference and corresponding estimated note,
their overlap ratio (OR) is defined as the ratio between the duration of
the time segment in which the two notes overlap and the time segment
spanned by the two notes combined (earliest onset to latest offset):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">OR</span> <span class="o">=</span> <span class="p">((</span><span class="nb">min</span><span class="p">(</span><span class="n">ref_offset</span><span class="p">,</span> <span class="n">est_offset</span><span class="p">)</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="n">ref_onset</span><span class="p">,</span> <span class="n">est_onset</span><span class="p">))</span> <span class="o">/</span>
<span class="gp">... </span>    <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">ref_offset</span><span class="p">,</span> <span class="n">est_offset</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">ref_onset</span><span class="p">,</span> <span class="n">est_onset</span><span class="p">)))</span>
</pre></div>
</div>
<p>The Average Overlap Ratio (AOR) is given by the mean OR computed over all
matching reference and estimated notes. The metric goes from 0 (worst) to 1
(best).</p>
<p>Note: this function assumes the matching of reference and estimated notes
(see <a class="reference internal" href="#mir_eval.transcription.match_notes" title="mir_eval.transcription.match_notes"><code class="xref py py-func docutils literal notranslate"><span class="pre">match_notes()</span></code></a>) has already been performed and is provided by the
<code class="docutils literal notranslate"><span class="pre">matching</span></code> parameter. Furthermore, it is highly recommended to validate
the intervals (see <a class="reference internal" href="#mir_eval.transcription.validate_intervals" title="mir_eval.transcription.validate_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">validate_intervals()</span></code></a>) before calling this
function, otherwise it is possible (though unlikely) for this function to
attempt a divide-by-zero operation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ref_intervals</strong><span class="classifier">np.ndarray, shape=(n,2)</span></dt><dd><p>Array of reference notes time intervals (onset and offset times)</p>
</dd>
<dt><strong>est_intervals</strong><span class="classifier">np.ndarray, shape=(m,2)</span></dt><dd><p>Array of estimated notes time intervals (onset and offset times)</p>
</dd>
<dt><strong>matching</strong><span class="classifier">list of tuples</span></dt><dd><p>A list of matched reference and estimated notes.
<code class="docutils literal notranslate"><span class="pre">matching[i]</span> <span class="pre">==</span> <span class="pre">(i,</span> <span class="pre">j)</span></code> where reference note <code class="docutils literal notranslate"><span class="pre">i</span></code> matches estimated
note <code class="docutils literal notranslate"><span class="pre">j</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>avg_overlap_ratio</strong><span class="classifier">float</span></dt><dd><p>The computed Average Overlap Ratio score</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.transcription.onset_precision_recall_f1">
<span class="sig-prename descclassname"><span class="pre">mir_eval.transcription.</span></span><span class="sig-name descname"><span class="pre">onset_precision_recall_f1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">onset_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.transcription.onset_precision_recall_f1" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Precision, Recall and F-measure of note onsets: an estimated
onset is considered correct if it is within +-50ms of a reference onset.
Note that this metric completely ignores note offset and note pitch. This
means an estimated onset will be considered correct if it matches a
reference onset, even if the onsets come from notes with completely
different pitches (i.e. notes that would not match with
<a class="reference internal" href="#mir_eval.transcription.match_notes" title="mir_eval.transcription.match_notes"><code class="xref py py-func docutils literal notranslate"><span class="pre">match_notes()</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ref_intervals</strong><span class="classifier">np.ndarray, shape=(n,2)</span></dt><dd><p>Array of reference notes time intervals (onset and offset times)</p>
</dd>
<dt><strong>est_intervals</strong><span class="classifier">np.ndarray, shape=(m,2)</span></dt><dd><p>Array of estimated notes time intervals (onset and offset times)</p>
</dd>
<dt><strong>onset_tolerance</strong><span class="classifier">float &gt; 0</span></dt><dd><p>The tolerance for an estimated note’s onset deviating from the
reference note’s onset, in seconds. Default is 0.05 (50 ms).</p>
</dd>
<dt><strong>strict</strong><span class="classifier">bool</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">strict=False</span></code> (the default), threshold checks for onset matching
are performed using <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> (less than or equal). If <code class="docutils literal notranslate"><span class="pre">strict=True</span></code>,
the threshold checks are performed using <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> (less than).</p>
</dd>
<dt><strong>beta</strong><span class="classifier">float &gt; 0</span></dt><dd><p>Weighting factor for f-measure (default value = 1.0).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>precision</strong><span class="classifier">float</span></dt><dd><p>The computed precision score</p>
</dd>
<dt><strong>recall</strong><span class="classifier">float</span></dt><dd><p>The computed recall score</p>
</dd>
<dt><strong>f_measure</strong><span class="classifier">float</span></dt><dd><p>The computed F-measure score</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_valued_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_valued_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">onset_precision</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">onset_recall</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">onset_f_measure</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">onset_precision_recall_f1</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.transcription.offset_precision_recall_f1">
<span class="sig-prename descclassname"><span class="pre">mir_eval.transcription.</span></span><span class="sig-name descname"><span class="pre">offset_precision_recall_f1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset_ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset_min_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.transcription.offset_precision_recall_f1" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Precision, Recall and F-measure of note offsets: an
estimated offset is considered correct if it is within +-50ms (or 20% of
the ref note duration, which ever is greater) of a reference offset. Note
that this metric completely ignores note onsets and note pitch. This means
an estimated offset will be considered correct if it matches a
reference offset, even if the offsets come from notes with completely
different pitches (i.e. notes that would not match with
<a class="reference internal" href="#mir_eval.transcription.match_notes" title="mir_eval.transcription.match_notes"><code class="xref py py-func docutils literal notranslate"><span class="pre">match_notes()</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ref_intervals</strong><span class="classifier">np.ndarray, shape=(n,2)</span></dt><dd><p>Array of reference notes time intervals (onset and offset times)</p>
</dd>
<dt><strong>est_intervals</strong><span class="classifier">np.ndarray, shape=(m,2)</span></dt><dd><p>Array of estimated notes time intervals (onset and offset times)</p>
</dd>
<dt><strong>offset_ratio</strong><span class="classifier">float &gt; 0 or None</span></dt><dd><p>The ratio of the reference note’s duration used to define the
offset_tolerance. Default is 0.2 (20%), meaning the
<code class="docutils literal notranslate"><span class="pre">offset_tolerance</span></code> will equal the <code class="docutils literal notranslate"><span class="pre">ref_duration</span> <span class="pre">*</span> <span class="pre">0.2</span></code>, or
<code class="docutils literal notranslate"><span class="pre">offset_min_tolerance</span></code> (0.05 by default, i.e. 50 ms), whichever is
greater.</p>
</dd>
<dt><strong>offset_min_tolerance</strong><span class="classifier">float &gt; 0</span></dt><dd><p>The minimum tolerance for offset matching. See <code class="docutils literal notranslate"><span class="pre">offset_ratio</span></code>
description for an explanation of how the offset tolerance is
determined.</p>
</dd>
<dt><strong>strict</strong><span class="classifier">bool</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">strict=False</span></code> (the default), threshold checks for onset matching
are performed using <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> (less than or equal). If <code class="docutils literal notranslate"><span class="pre">strict=True</span></code>,
the threshold checks are performed using <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> (less than).</p>
</dd>
<dt><strong>beta</strong><span class="classifier">float &gt; 0</span></dt><dd><p>Weighting factor for f-measure (default value = 1.0).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>precision</strong><span class="classifier">float</span></dt><dd><p>The computed precision score</p>
</dd>
<dt><strong>recall</strong><span class="classifier">float</span></dt><dd><p>The computed recall score</p>
</dd>
<dt><strong>f_measure</strong><span class="classifier">float</span></dt><dd><p>The computed F-measure score</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_valued_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_valued_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">offset_precision</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">offset_recall</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">offset_f_measure</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">offset_precision_recall_f1</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.transcription.evaluate">
<span class="sig-prename descclassname"><span class="pre">mir_eval.transcription.</span></span><span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_pitches</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_pitches</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.transcription.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all metrics for the given reference and estimated annotations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ref_intervals</strong><span class="classifier">np.ndarray, shape=(n,2)</span></dt><dd><p>Array of reference notes time intervals (onset and offset times)</p>
</dd>
<dt><strong>ref_pitches</strong><span class="classifier">np.ndarray, shape=(n,)</span></dt><dd><p>Array of reference pitch values in Hertz</p>
</dd>
<dt><strong>est_intervals</strong><span class="classifier">np.ndarray, shape=(m,2)</span></dt><dd><p>Array of estimated notes time intervals (onset and offset times)</p>
</dd>
<dt><strong>est_pitches</strong><span class="classifier">np.ndarray, shape=(m,)</span></dt><dd><p>Array of estimated pitch values in Hertz</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scores</strong><span class="classifier">dict</span></dt><dd><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_pitches</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_valued_intervals</span><span class="p">(</span>
<span class="gp">... </span>   <span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_pitches</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_valued_intervals</span><span class="p">(</span>
<span class="gp">... </span>   <span class="s1">&#39;estimate.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_pitches</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_pitches</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="module-mir_eval.transcription_velocity">
<span id="mir-eval-transcription-velocity"></span><h3><a class="reference internal" href="#module-mir_eval.transcription_velocity" title="mir_eval.transcription_velocity"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.transcription_velocity</span></code></a><a class="headerlink" href="#module-mir_eval.transcription_velocity" title="Permalink to this headline">¶</a></h3>
<p>Transcription evaluation, as defined in <a class="reference internal" href="#module-mir_eval.transcription" title="mir_eval.transcription"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.transcription</span></code></a>, does not
take into account the velocities of reference and estimated notes. This
submodule implements a variant of
<a class="reference internal" href="#mir_eval.transcription.precision_recall_f1_overlap" title="mir_eval.transcription.precision_recall_f1_overlap"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.transcription.precision_recall_f1_overlap()</span></code></a> which
additionally considers note velocity when determining whether a note is
correctly transcribed. This is done by defining a new function
<a class="reference internal" href="#mir_eval.transcription_velocity.match_notes" title="mir_eval.transcription_velocity.match_notes"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.transcription_velocity.match_notes()</span></code></a> which first calls
<a class="reference internal" href="#mir_eval.transcription.match_notes" title="mir_eval.transcription.match_notes"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.transcription.match_notes()</span></code></a> to get a note matching based on
onset, offset, and pitch. Then, we follow the evaluation procedure described in
<a class="footnote-reference brackets" href="#hawthorne2018onsets" id="id44">16</a> to test whether an estimated note should be considered
correct:</p>
<ol class="arabic simple">
<li><p>Reference velocities are re-scaled to the range [0, 1].</p></li>
<li><p>A linear regression is performed to estimate global scale and offset
parameters which minimize the L2 distance between matched estimated and
(rescaled) reference notes.</p></li>
<li><p>The scale and offset parameters are used to rescale estimated
velocities.</p></li>
<li><p>An estimated/reference note pair which has been matched according to the
onset, offset, and pitch is further only considered correct if the rescaled
velocities are within a predefined threshold, defaulting to 0.1.</p></li>
</ol>
<p><a class="reference internal" href="#mir_eval.transcription_velocity.match_notes" title="mir_eval.transcription_velocity.match_notes"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.transcription_velocity.match_notes()</span></code></a> is used to define a new
variant <a class="reference internal" href="#mir_eval.transcription_velocity.precision_recall_f1_overlap" title="mir_eval.transcription_velocity.precision_recall_f1_overlap"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.transcription_velocity.precision_recall_f1_overlap()</span></code></a>
which considers velocity.</p>
<section id="id45">
<h4>Conventions<a class="headerlink" href="#id45" title="Permalink to this headline">¶</a></h4>
<p>This submodule follows the conventions of <a class="reference internal" href="#module-mir_eval.transcription" title="mir_eval.transcription"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.transcription</span></code></a> and
additionally requires velocities to be provided as MIDI velocities in the range
[0, 127].</p>
</section>
<section id="id46">
<h4>Metrics<a class="headerlink" href="#id46" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><a class="reference internal" href="#mir_eval.transcription_velocity.precision_recall_f1_overlap" title="mir_eval.transcription_velocity.precision_recall_f1_overlap"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.transcription_velocity.precision_recall_f1_overlap()</span></code></a>: The
precision, recall, F-measure, and Average Overlap Ratio of the note
transcription, where an estimated note is considered correct if its pitch,
onset, velocity and (optionally) offset are sufficiently close to a reference
note.</p></li>
</ul>
</section>
<section id="id47">
<h4>References<a class="headerlink" href="#id47" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><dl class="footnote brackets">
<dt class="label" id="hawthorne2018onsets"><span class="brackets"><a class="fn-backref" href="#id44">16</a></span></dt>
<dd><p>Curtis Hawthorne, Erich Elsen, Jialin Song, Adam
Roberts, Ian Simon, Colin Raffel, Jesse Engel, Sageev Oore, and Douglas
Eck, “Onsets and Frames: Dual-Objective Piano Transcription”, Proceedings
of the 19th International Society for Music Information Retrieval
Conference, 2018.</p>
</dd>
</dl>
</div></blockquote>
<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.transcription_velocity.validate">
<span class="sig-prename descclassname"><span class="pre">mir_eval.transcription_velocity.</span></span><span class="sig-name descname"><span class="pre">validate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_pitches</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_velocities</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_pitches</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_velocities</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.transcription_velocity.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations have valid time intervals, pitches,
and velocities, and throws helpful errors if not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ref_intervals</strong><span class="classifier">np.ndarray, shape=(n,2)</span></dt><dd><p>Array of reference notes time intervals (onset and offset times)</p>
</dd>
<dt><strong>ref_pitches</strong><span class="classifier">np.ndarray, shape=(n,)</span></dt><dd><p>Array of reference pitch values in Hertz</p>
</dd>
<dt><strong>ref_velocities</strong><span class="classifier">np.ndarray, shape=(n,)</span></dt><dd><p>Array of MIDI velocities (i.e. between 0 and 127) of reference notes</p>
</dd>
<dt><strong>est_intervals</strong><span class="classifier">np.ndarray, shape=(m,2)</span></dt><dd><p>Array of estimated notes time intervals (onset and offset times)</p>
</dd>
<dt><strong>est_pitches</strong><span class="classifier">np.ndarray, shape=(m,)</span></dt><dd><p>Array of estimated pitch values in Hertz</p>
</dd>
<dt><strong>est_velocities</strong><span class="classifier">np.ndarray, shape=(m,)</span></dt><dd><p>Array of MIDI velocities (i.e. between 0 and 127) of estimated notes</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.transcription_velocity.match_notes">
<span class="sig-prename descclassname"><span class="pre">mir_eval.transcription_velocity.</span></span><span class="sig-name descname"><span class="pre">match_notes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_pitches</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_velocities</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_pitches</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_velocities</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">onset_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pitch_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset_ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset_min_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">velocity_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.transcription_velocity.match_notes" title="Permalink to this definition">¶</a></dt>
<dd><p>Match notes, taking note velocity into consideration.</p>
<p>This function first calls <a class="reference internal" href="#mir_eval.transcription.match_notes" title="mir_eval.transcription.match_notes"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.transcription.match_notes()</span></code></a> to
match notes according to the supplied intervals, pitches, onset, offset,
and pitch tolerances. The velocities of the matched notes are then used to
estimate a slope and intercept which can rescale the estimated velocities
so that they are as close as possible (in L2 sense) to their matched
reference velocities. Velocities are then normalized to the range [0, 1]. A
estimated note is then further only considered correct if its velocity is
within <code class="docutils literal notranslate"><span class="pre">velocity_tolerance</span></code> of its matched (according to pitch and
timing) reference note.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ref_intervals</strong><span class="classifier">np.ndarray, shape=(n,2)</span></dt><dd><p>Array of reference notes time intervals (onset and offset times)</p>
</dd>
<dt><strong>ref_pitches</strong><span class="classifier">np.ndarray, shape=(n,)</span></dt><dd><p>Array of reference pitch values in Hertz</p>
</dd>
<dt><strong>ref_velocities</strong><span class="classifier">np.ndarray, shape=(n,)</span></dt><dd><p>Array of MIDI velocities (i.e. between 0 and 127) of reference notes</p>
</dd>
<dt><strong>est_intervals</strong><span class="classifier">np.ndarray, shape=(m,2)</span></dt><dd><p>Array of estimated notes time intervals (onset and offset times)</p>
</dd>
<dt><strong>est_pitches</strong><span class="classifier">np.ndarray, shape=(m,)</span></dt><dd><p>Array of estimated pitch values in Hertz</p>
</dd>
<dt><strong>est_velocities</strong><span class="classifier">np.ndarray, shape=(m,)</span></dt><dd><p>Array of MIDI velocities (i.e. between 0 and 127) of estimated notes</p>
</dd>
<dt><strong>onset_tolerance</strong><span class="classifier">float &gt; 0</span></dt><dd><p>The tolerance for an estimated note’s onset deviating from the
reference note’s onset, in seconds. Default is 0.05 (50 ms).</p>
</dd>
<dt><strong>pitch_tolerance</strong><span class="classifier">float &gt; 0</span></dt><dd><p>The tolerance for an estimated note’s pitch deviating from the
reference note’s pitch, in cents. Default is 50.0 (50 cents).</p>
</dd>
<dt><strong>offset_ratio</strong><span class="classifier">float &gt; 0 or None</span></dt><dd><p>The ratio of the reference note’s duration used to define the
offset_tolerance. Default is 0.2 (20%), meaning the
<code class="docutils literal notranslate"><span class="pre">offset_tolerance</span></code> will equal the <code class="docutils literal notranslate"><span class="pre">ref_duration</span> <span class="pre">*</span> <span class="pre">0.2</span></code>, or 0.05 (50
ms), whichever is greater. If <code class="docutils literal notranslate"><span class="pre">offset_ratio</span></code> is set to <code class="docutils literal notranslate"><span class="pre">None</span></code>,
offsets are ignored in the matching.</p>
</dd>
<dt><strong>offset_min_tolerance</strong><span class="classifier">float &gt; 0</span></dt><dd><p>The minimum tolerance for offset matching. See offset_ratio description
for an explanation of how the offset tolerance is determined. Note:
this parameter only influences the results if <code class="docutils literal notranslate"><span class="pre">offset_ratio</span></code> is not
<code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
<dt><strong>strict</strong><span class="classifier">bool</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">strict=False</span></code> (the default), threshold checks for onset, offset,
and pitch matching are performed using <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> (less than or equal). If
<code class="docutils literal notranslate"><span class="pre">strict=True</span></code>, the threshold checks are performed using <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> (less
than).</p>
</dd>
<dt><strong>velocity_tolerance</strong><span class="classifier">float &gt; 0</span></dt><dd><p>Estimated notes are considered correct if, after rescaling and
normalization to [0, 1], they are within <code class="docutils literal notranslate"><span class="pre">velocity_tolerance</span></code> of a
matched reference note.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>matching</strong><span class="classifier">list of tuples</span></dt><dd><p>A list of matched reference and estimated notes.
<code class="docutils literal notranslate"><span class="pre">matching[i]</span> <span class="pre">==</span> <span class="pre">(i,</span> <span class="pre">j)</span></code> where reference note <code class="docutils literal notranslate"><span class="pre">i</span></code> matches estimated
note <code class="docutils literal notranslate"><span class="pre">j</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.transcription_velocity.precision_recall_f1_overlap">
<span class="sig-prename descclassname"><span class="pre">mir_eval.transcription_velocity.</span></span><span class="sig-name descname"><span class="pre">precision_recall_f1_overlap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_pitches</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_velocities</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_pitches</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_velocities</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">onset_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pitch_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset_ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset_min_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">velocity_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.transcription_velocity.precision_recall_f1_overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Precision, Recall and F-measure of correct vs incorrectly
transcribed notes, and the Average Overlap Ratio for correctly transcribed
notes (see <a class="reference internal" href="#mir_eval.transcription.average_overlap_ratio" title="mir_eval.transcription.average_overlap_ratio"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.transcription.average_overlap_ratio()</span></code></a>).
“Correctness” is determined based on note onset, velocity, pitch and
(optionally) offset. An estimated note is considered correct if</p>
<ol class="arabic simple">
<li><p>Its onset is within <code class="docutils literal notranslate"><span class="pre">onset_tolerance</span></code> (default +-50ms) of a
reference note</p></li>
<li><p>Its pitch (F0) is within +/- <code class="docutils literal notranslate"><span class="pre">pitch_tolerance</span></code> (default one
quarter tone, 50 cents) of the corresponding reference note</p></li>
<li><p>Its velocity, after normalizing reference velocities to the range
[0, 1] and globally rescaling estimated velocities to minimize L2
distance between matched reference notes, is within
<code class="docutils literal notranslate"><span class="pre">velocity_tolerance</span></code> (default 0.1) the corresponding reference note</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">offset_ratio</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, note offsets are ignored in the
comparison. Otherwise, on top of the above requirements, a correct
returned note is required to have an offset value within
<cite>offset_ratio`</cite> (default 20%) of the reference note’s duration around
the reference note’s offset, or within <code class="docutils literal notranslate"><span class="pre">offset_min_tolerance</span></code>
(default 50 ms), whichever is larger.</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ref_intervals</strong><span class="classifier">np.ndarray, shape=(n,2)</span></dt><dd><p>Array of reference notes time intervals (onset and offset times)</p>
</dd>
<dt><strong>ref_pitches</strong><span class="classifier">np.ndarray, shape=(n,)</span></dt><dd><p>Array of reference pitch values in Hertz</p>
</dd>
<dt><strong>ref_velocities</strong><span class="classifier">np.ndarray, shape=(n,)</span></dt><dd><p>Array of MIDI velocities (i.e. between 0 and 127) of reference notes</p>
</dd>
<dt><strong>est_intervals</strong><span class="classifier">np.ndarray, shape=(m,2)</span></dt><dd><p>Array of estimated notes time intervals (onset and offset times)</p>
</dd>
<dt><strong>est_pitches</strong><span class="classifier">np.ndarray, shape=(m,)</span></dt><dd><p>Array of estimated pitch values in Hertz</p>
</dd>
<dt><strong>est_velocities</strong><span class="classifier">np.ndarray, shape=(n,)</span></dt><dd><p>Array of MIDI velocities (i.e. between 0 and 127) of estimated notes</p>
</dd>
<dt><strong>onset_tolerance</strong><span class="classifier">float &gt; 0</span></dt><dd><p>The tolerance for an estimated note’s onset deviating from the
reference note’s onset, in seconds. Default is 0.05 (50 ms).</p>
</dd>
<dt><strong>pitch_tolerance</strong><span class="classifier">float &gt; 0</span></dt><dd><p>The tolerance for an estimated note’s pitch deviating from the
reference note’s pitch, in cents. Default is 50.0 (50 cents).</p>
</dd>
<dt><strong>offset_ratio</strong><span class="classifier">float &gt; 0 or None</span></dt><dd><p>The ratio of the reference note’s duration used to define the
offset_tolerance. Default is 0.2 (20%), meaning the
<code class="docutils literal notranslate"><span class="pre">offset_tolerance</span></code> will equal the <code class="docutils literal notranslate"><span class="pre">ref_duration</span> <span class="pre">*</span> <span class="pre">0.2</span></code>, or
<code class="docutils literal notranslate"><span class="pre">offset_min_tolerance</span></code> (0.05 by default, i.e. 50 ms), whichever is
greater. If <code class="docutils literal notranslate"><span class="pre">offset_ratio</span></code> is set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, offsets are ignored in
the evaluation.</p>
</dd>
<dt><strong>offset_min_tolerance</strong><span class="classifier">float &gt; 0</span></dt><dd><p>The minimum tolerance for offset matching. See <code class="docutils literal notranslate"><span class="pre">offset_ratio</span></code>
description for an explanation of how the offset tolerance is
determined. Note: this parameter only influences the results if
<code class="docutils literal notranslate"><span class="pre">offset_ratio</span></code> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
<dt><strong>strict</strong><span class="classifier">bool</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">strict=False</span></code> (the default), threshold checks for onset, offset,
and pitch matching are performed using <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> (less than or equal). If
<code class="docutils literal notranslate"><span class="pre">strict=True</span></code>, the threshold checks are performed using <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> (less
than).</p>
</dd>
<dt><strong>velocity_tolerance</strong><span class="classifier">float &gt; 0</span></dt><dd><p>Estimated notes are considered correct if, after rescaling and
normalization to [0, 1], they are within <code class="docutils literal notranslate"><span class="pre">velocity_tolerance</span></code> of a
matched reference note.</p>
</dd>
<dt><strong>beta</strong><span class="classifier">float &gt; 0</span></dt><dd><p>Weighting factor for f-measure (default value = 1.0).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>precision</strong><span class="classifier">float</span></dt><dd><p>The computed precision score</p>
</dd>
<dt><strong>recall</strong><span class="classifier">float</span></dt><dd><p>The computed recall score</p>
</dd>
<dt><strong>f_measure</strong><span class="classifier">float</span></dt><dd><p>The computed F-measure score</p>
</dd>
<dt><strong>avg_overlap_ratio</strong><span class="classifier">float</span></dt><dd><p>The computed Average Overlap Ratio score</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.transcription_velocity.evaluate">
<span class="sig-prename descclassname"><span class="pre">mir_eval.transcription_velocity.</span></span><span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_pitches</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_velocities</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_pitches</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_velocities</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.transcription_velocity.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all metrics for the given reference and estimated annotations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ref_intervals</strong><span class="classifier">np.ndarray, shape=(n,2)</span></dt><dd><p>Array of reference notes time intervals (onset and offset times)</p>
</dd>
<dt><strong>ref_pitches</strong><span class="classifier">np.ndarray, shape=(n,)</span></dt><dd><p>Array of reference pitch values in Hertz</p>
</dd>
<dt><strong>ref_velocities</strong><span class="classifier">np.ndarray, shape=(n,)</span></dt><dd><p>Array of MIDI velocities (i.e. between 0 and 127) of reference notes</p>
</dd>
<dt><strong>est_intervals</strong><span class="classifier">np.ndarray, shape=(m,2)</span></dt><dd><p>Array of estimated notes time intervals (onset and offset times)</p>
</dd>
<dt><strong>est_pitches</strong><span class="classifier">np.ndarray, shape=(m,)</span></dt><dd><p>Array of estimated pitch values in Hertz</p>
</dd>
<dt><strong>est_velocities</strong><span class="classifier">np.ndarray, shape=(n,)</span></dt><dd><p>Array of MIDI velocities (i.e. between 0 and 127) of estimated notes</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scores</strong><span class="classifier">dict</span></dt><dd><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="module-mir_eval.key">
<span id="mir-eval-key"></span><h3><a class="reference internal" href="#module-mir_eval.key" title="mir_eval.key"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.key</span></code></a><a class="headerlink" href="#module-mir_eval.key" title="Permalink to this headline">¶</a></h3>
<p>Key Detection involves determining the underlying key (distribution of notes
and note transitions) in a piece of music.  Key detection algorithms are
evaluated by comparing their estimated key to a ground-truth reference key and
reporting a score according to the relationship of the keys.</p>
<section id="id48">
<h4>Conventions<a class="headerlink" href="#id48" title="Permalink to this headline">¶</a></h4>
<p>Keys are represented as strings of the form <code class="docutils literal notranslate"><span class="pre">'(key)</span> <span class="pre">(mode)'</span></code>, e.g. <code class="docutils literal notranslate"><span class="pre">'C#</span>
<span class="pre">major'</span></code> or <code class="docutils literal notranslate"><span class="pre">'Fb</span> <span class="pre">minor'</span></code>.  The case of the key is ignored.  Note that certain
key strings are equivalent, e.g. <code class="docutils literal notranslate"><span class="pre">'C#</span> <span class="pre">major'</span></code> and <code class="docutils literal notranslate"><span class="pre">'Db</span> <span class="pre">major'</span></code>.  The mode
may only be specified as either <code class="docutils literal notranslate"><span class="pre">'major'</span></code> or <code class="docutils literal notranslate"><span class="pre">'minor'</span></code>, no other mode
strings will be accepted.</p>
</section>
<section id="id49">
<h4>Metrics<a class="headerlink" href="#id49" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><a class="reference internal" href="#mir_eval.key.weighted_score" title="mir_eval.key.weighted_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.key.weighted_score()</span></code></a>: Heuristic scoring of the relation of two
keys.</p></li>
</ul>
<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.key.validate_key">
<span class="sig-prename descclassname"><span class="pre">mir_eval.key.</span></span><span class="sig-name descname"><span class="pre">validate_key</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.key.validate_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that a key is well-formatted, e.g. in the form <code class="docutils literal notranslate"><span class="pre">'C#</span> <span class="pre">major'</span></code>.
The Key can be ‘X’ if it is not possible to categorize the Key and mode
can be ‘other’ if it can’t be categorized as major or minor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>key</strong><span class="classifier">str</span></dt><dd><p>Key to verify</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.key.validate">
<span class="sig-prename descclassname"><span class="pre">mir_eval.key.</span></span><span class="sig-name descname"><span class="pre">validate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.key.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a metric are valid key strings and
throws helpful errors if not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_key</strong><span class="classifier">str</span></dt><dd><p>Reference key string.</p>
</dd>
<dt><strong>estimated_key</strong><span class="classifier">str</span></dt><dd><p>Estimated key string.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.key.split_key_string">
<span class="sig-prename descclassname"><span class="pre">mir_eval.key.</span></span><span class="sig-name descname"><span class="pre">split_key_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.key.split_key_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Splits a key string (of the form, e.g. <code class="docutils literal notranslate"><span class="pre">'C#</span> <span class="pre">major'</span></code>), into a tuple of
<code class="docutils literal notranslate"><span class="pre">(key,</span> <span class="pre">mode)</span></code> where <code class="docutils literal notranslate"><span class="pre">key</span></code> is is an integer representing the semitone
distance from C.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>key</strong><span class="classifier">str</span></dt><dd><p>String representing a key.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>key</strong><span class="classifier">int</span></dt><dd><p>Number of semitones above C.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str</span></dt><dd><p>String representing the mode.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.key.weighted_score">
<span class="sig-prename descclassname"><span class="pre">mir_eval.key.</span></span><span class="sig-name descname"><span class="pre">weighted_score</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.key.weighted_score" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a heuristic score which is weighted according to the
relationship of the reference and estimated key, as follows:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 89%" />
<col style="width: 11%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Relationship</p></td>
<td><p>Score</p></td>
</tr>
<tr class="row-even"><td><p>Same key and mode</p></td>
<td><p>1.0</p></td>
</tr>
<tr class="row-odd"><td><p>Estimated key is a perfect fifth above reference key</p></td>
<td><p>0.5</p></td>
</tr>
<tr class="row-even"><td><p>Relative major/minor (same key signature)</p></td>
<td><p>0.3</p></td>
</tr>
<tr class="row-odd"><td><p>Parallel major/minor (same key)</p></td>
<td><p>0.2</p></td>
</tr>
<tr class="row-even"><td><p>Other</p></td>
<td><p>0.0</p></td>
</tr>
</tbody>
</table>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_key</strong><span class="classifier">str</span></dt><dd><p>Reference key string.</p>
</dd>
<dt><strong>estimated_key</strong><span class="classifier">str</span></dt><dd><p>Estimated key string.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>score</strong><span class="classifier">float</span></dt><dd><p>Score representing how closely related the keys are.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_key</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_key</span><span class="p">(</span><span class="s1">&#39;ref.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_key</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_key</span><span class="p">(</span><span class="s1">&#39;est.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">key</span><span class="o">.</span><span class="n">weighted_score</span><span class="p">(</span><span class="n">ref_key</span><span class="p">,</span> <span class="n">est_key</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.key.evaluate">
<span class="sig-prename descclassname"><span class="pre">mir_eval.key.</span></span><span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_key</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.key.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all metrics for the given reference and estimated annotations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ref_key</strong><span class="classifier">str</span></dt><dd><p>Reference key string.</p>
</dd>
<dt><strong>ref_key</strong><span class="classifier">str</span></dt><dd><p>Estimated key string.</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scores</strong><span class="classifier">dict</span></dt><dd><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_key</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_key</span><span class="p">(</span><span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_key</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_key</span><span class="p">(</span><span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">key</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ref_key</span><span class="p">,</span> <span class="n">est_key</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="module-mir_eval.util">
<span id="mir-eval-util"></span><h3><a class="reference internal" href="#module-mir_eval.util" title="mir_eval.util"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.util</span></code></a><a class="headerlink" href="#module-mir_eval.util" title="Permalink to this headline">¶</a></h3>
<p>This submodule collects useful functionality required across the task
submodules, such as preprocessing, validation, and common computations.</p>
<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.util.index_labels">
<span class="sig-prename descclassname"><span class="pre">mir_eval.util.</span></span><span class="sig-name descname"><span class="pre">index_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">case_sensitive</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.index_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a list of string identifiers into numerical indices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>labels</strong><span class="classifier">list of strings, shape=(n,)</span></dt><dd><p>A list of annotations, e.g., segment or chord labels from an
annotation file.</p>
</dd>
<dt><strong>case_sensitive</strong><span class="classifier">bool</span></dt><dd><p>Set to True to enable case-sensitive label indexing
(Default value = False)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>indices</strong><span class="classifier">list, shape=(n,)</span></dt><dd><p>Numerical representation of <code class="docutils literal notranslate"><span class="pre">labels</span></code></p>
</dd>
<dt><strong>index_to_label</strong><span class="classifier">dict</span></dt><dd><p>Mapping to convert numerical indices back to labels.
<code class="docutils literal notranslate"><span class="pre">labels[i]</span> <span class="pre">==</span> <span class="pre">index_to_label[indices[i]]</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.util.generate_labels">
<span class="sig-prename descclassname"><span class="pre">mir_eval.util.</span></span><span class="sig-name descname"><span class="pre">generate_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">items</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'__'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.generate_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an array of items (e.g. events, intervals), create a synthetic label
for each event of the form ‘(label prefix)(item number)’</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>items</strong><span class="classifier">list-like</span></dt><dd><p>A list or array of events or intervals</p>
</dd>
<dt><strong>prefix</strong><span class="classifier">str</span></dt><dd><p>This prefix will be prepended to all synthetically generated labels
(Default value = ‘__’)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>labels</strong><span class="classifier">list of str</span></dt><dd><p>Synthetically generated labels</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.util.intervals_to_samples">
<span class="sig-prename descclassname"><span class="pre">mir_eval.util.</span></span><span class="sig-name descname"><span class="pre">intervals_to_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.intervals_to_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an array of labeled time intervals to annotated samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>intervals</strong><span class="classifier">np.ndarray, shape=(n, d)</span></dt><dd><p>An array of time intervals, as returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_intervals()</span></code></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.
The <code class="docutils literal notranslate"><span class="pre">i</span></code> th interval spans time <code class="docutils literal notranslate"><span class="pre">intervals[i,</span> <span class="pre">0]</span></code> to
<code class="docutils literal notranslate"><span class="pre">intervals[i,</span> <span class="pre">1]</span></code>.</p>
</dd>
<dt><strong>labels</strong><span class="classifier">list, shape=(n,)</span></dt><dd><p>The annotation for each interval</p>
</dd>
<dt><strong>offset</strong><span class="classifier">float &gt; 0</span></dt><dd><p>Phase offset of the sampled time grid (in seconds)
(Default value = 0)</p>
</dd>
<dt><strong>sample_size</strong><span class="classifier">float &gt; 0</span></dt><dd><p>duration of each sample to be generated (in seconds)
(Default value = 0.1)</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">type(labels[0])</span></dt><dd><p>Object to use for the label with out-of-range time points.
(Default value = None)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>sample_times</strong><span class="classifier">list</span></dt><dd><p>list of sample times</p>
</dd>
<dt><strong>sample_labels</strong><span class="classifier">list</span></dt><dd><p>array of labels for each generated sample</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Intervals will be rounded down to the nearest multiple
of <code class="docutils literal notranslate"><span class="pre">sample_size</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.util.interpolate_intervals">
<span class="sig-prename descclassname"><span class="pre">mir_eval.util.</span></span><span class="sig-name descname"><span class="pre">interpolate_intervals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.interpolate_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign labels to a set of points in time given a set of intervals.</p>
<p>Time points that do not lie within an interval are mapped to <cite>fill_value</cite>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>intervals</strong><span class="classifier">np.ndarray, shape=(n, 2)</span></dt><dd><p>An array of time intervals, as returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_intervals()</span></code></a>.
The <code class="docutils literal notranslate"><span class="pre">i</span></code> th interval spans time <code class="docutils literal notranslate"><span class="pre">intervals[i,</span> <span class="pre">0]</span></code> to
<code class="docutils literal notranslate"><span class="pre">intervals[i,</span> <span class="pre">1]</span></code>.</p>
<p>Intervals are assumed to be disjoint.</p>
</dd>
<dt><strong>labels</strong><span class="classifier">list, shape=(n,)</span></dt><dd><p>The annotation for each interval</p>
</dd>
<dt><strong>time_points</strong><span class="classifier">array_like, shape=(m,)</span></dt><dd><p>Points in time to assign labels.  These must be in
non-decreasing order.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">type(labels[0])</span></dt><dd><p>Object to use for the label with out-of-range time points.
(Default value = None)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>aligned_labels</strong><span class="classifier">list</span></dt><dd><p>Labels corresponding to the given time points.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>time_points</cite> is not in non-decreasing order.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.util.sort_labeled_intervals">
<span class="sig-prename descclassname"><span class="pre">mir_eval.util.</span></span><span class="sig-name descname"><span class="pre">sort_labeled_intervals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.sort_labeled_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort intervals, and optionally, their corresponding labels
according to start time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>intervals</strong><span class="classifier">np.ndarray, shape=(n, 2)</span></dt><dd><p>The input intervals</p>
</dd>
<dt><strong>labels</strong><span class="classifier">list, optional</span></dt><dd><p>Labels for each interval</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>intervals_sorted or (intervals_sorted, labels_sorted)</dt><dd><p>Labels are only returned if provided as input</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.util.f_measure">
<span class="sig-prename descclassname"><span class="pre">mir_eval.util.</span></span><span class="sig-name descname"><span class="pre">f_measure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">precision</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">recall</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.f_measure" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the f-measure from precision and recall scores.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>precision</strong><span class="classifier">float in (0, 1]</span></dt><dd><p>Precision</p>
</dd>
<dt><strong>recall</strong><span class="classifier">float in (0, 1]</span></dt><dd><p>Recall</p>
</dd>
<dt><strong>beta</strong><span class="classifier">float &gt; 0</span></dt><dd><p>Weighting factor for f-measure
(Default value = 1.0)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>f_measure</strong><span class="classifier">float</span></dt><dd><p>The weighted f-measure</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.util.intervals_to_boundaries">
<span class="sig-prename descclassname"><span class="pre">mir_eval.util.</span></span><span class="sig-name descname"><span class="pre">intervals_to_boundaries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.intervals_to_boundaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert interval times into boundaries.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>intervals</strong><span class="classifier">np.ndarray, shape=(n_events, 2)</span></dt><dd><p>Array of interval start and end-times</p>
</dd>
<dt><strong>q</strong><span class="classifier">int</span></dt><dd><p>Number of decimals to round to. (Default value = 5)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>boundaries</strong><span class="classifier">np.ndarray</span></dt><dd><p>Interval boundary times, including the end of the final interval</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.util.boundaries_to_intervals">
<span class="sig-prename descclassname"><span class="pre">mir_eval.util.</span></span><span class="sig-name descname"><span class="pre">boundaries_to_intervals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">boundaries</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.boundaries_to_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an array of event times into intervals</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>boundaries</strong><span class="classifier">list-like</span></dt><dd><p>List-like of event times.  These are assumed to be unique
timestamps in ascending order.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>intervals</strong><span class="classifier">np.ndarray, shape=(n_intervals, 2)</span></dt><dd><p>Start and end time for each interval</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.util.adjust_intervals">
<span class="sig-prename descclassname"><span class="pre">mir_eval.util.</span></span><span class="sig-name descname"><span class="pre">adjust_intervals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t_min</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'__T_MIN'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'__T_MAX'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.adjust_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjust a list of time intervals to span the range <code class="docutils literal notranslate"><span class="pre">[t_min,</span> <span class="pre">t_max]</span></code>.</p>
<p>Any intervals lying completely outside the specified range will be removed.</p>
<p>Any intervals lying partially outside the specified range will be cropped.</p>
<p>If the specified range exceeds the span of the provided data in either
direction, additional intervals will be appended.  If an interval is
appended at the beginning, it will be given the label <code class="docutils literal notranslate"><span class="pre">start_label</span></code>; if
an interval is appended at the end, it will be given the label
<code class="docutils literal notranslate"><span class="pre">end_label</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>intervals</strong><span class="classifier">np.ndarray, shape=(n_events, 2)</span></dt><dd><p>Array of interval start and end-times</p>
</dd>
<dt><strong>labels</strong><span class="classifier">list, len=n_events or None</span></dt><dd><p>List of labels
(Default value = None)</p>
</dd>
<dt><strong>t_min</strong><span class="classifier">float or None</span></dt><dd><p>Minimum interval start time.
(Default value = 0.0)</p>
</dd>
<dt><strong>t_max</strong><span class="classifier">float or None</span></dt><dd><p>Maximum interval end time.
(Default value = None)</p>
</dd>
<dt><strong>start_label</strong><span class="classifier">str or float or int</span></dt><dd><p>Label to give any intervals appended at the beginning
(Default value = ‘__T_MIN’)</p>
</dd>
<dt><strong>end_label</strong><span class="classifier">str or float or int</span></dt><dd><p>Label to give any intervals appended at the end
(Default value = ‘__T_MAX’)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>new_intervals</strong><span class="classifier">np.ndarray</span></dt><dd><p>Intervals spanning <code class="docutils literal notranslate"><span class="pre">[t_min,</span> <span class="pre">t_max]</span></code></p>
</dd>
<dt><strong>new_labels</strong><span class="classifier">list</span></dt><dd><p>List of labels for <code class="docutils literal notranslate"><span class="pre">new_labels</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.util.adjust_events">
<span class="sig-prename descclassname"><span class="pre">mir_eval.util.</span></span><span class="sig-name descname"><span class="pre">adjust_events</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">events</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t_min</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label_prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'__'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.adjust_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjust the given list of event times to span the range
<code class="docutils literal notranslate"><span class="pre">[t_min,</span> <span class="pre">t_max]</span></code>.</p>
<p>Any event times outside of the specified range will be removed.</p>
<p>If the times do not span <code class="docutils literal notranslate"><span class="pre">[t_min,</span> <span class="pre">t_max]</span></code>, additional events will be
added with the prefix <code class="docutils literal notranslate"><span class="pre">label_prefix</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>events</strong><span class="classifier">np.ndarray</span></dt><dd><p>Array of event times (seconds)</p>
</dd>
<dt><strong>labels</strong><span class="classifier">list or None</span></dt><dd><p>List of labels
(Default value = None)</p>
</dd>
<dt><strong>t_min</strong><span class="classifier">float or None</span></dt><dd><p>Minimum valid event time.
(Default value = 0.0)</p>
</dd>
<dt><strong>t_max</strong><span class="classifier">float or None</span></dt><dd><p>Maximum valid event time.
(Default value = None)</p>
</dd>
<dt><strong>label_prefix</strong><span class="classifier">str</span></dt><dd><p>Prefix string to use for synthetic labels
(Default value = ‘__’)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>new_times</strong><span class="classifier">np.ndarray</span></dt><dd><p>Event times corrected to the given range.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.util.intersect_files">
<span class="sig-prename descclassname"><span class="pre">mir_eval.util.</span></span><span class="sig-name descname"><span class="pre">intersect_files</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">flist1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flist2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.intersect_files" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the intersection of two sets of filepaths, based on the file name
(after the final ‘/’) and ignoring the file extension.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>flist1</strong><span class="classifier">list</span></dt><dd><p>first list of filepaths</p>
</dd>
<dt><strong>flist2</strong><span class="classifier">list</span></dt><dd><p>second list of filepaths</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>sublist1</strong><span class="classifier">list</span></dt><dd><p>subset of filepaths with matching stems from <code class="docutils literal notranslate"><span class="pre">flist1</span></code></p>
</dd>
<dt><strong>sublist2</strong><span class="classifier">list</span></dt><dd><p>corresponding filepaths from <code class="docutils literal notranslate"><span class="pre">flist2</span></code></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">flist1</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;/a/b/abc.lab&#39;</span><span class="p">,</span> <span class="s1">&#39;/c/d/123.lab&#39;</span><span class="p">,</span> <span class="s1">&#39;/e/f/xyz.lab&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flist2</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;/g/h/xyz.npy&#39;</span><span class="p">,</span> <span class="s1">&#39;/i/j/123.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;/k/l/456.lab&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sublist1</span><span class="p">,</span> <span class="n">sublist2</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intersect_files</span><span class="p">(</span><span class="n">flist1</span><span class="p">,</span> <span class="n">flist2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">sublist1</span>
<span class="go">[&#39;/e/f/xyz.lab&#39;, &#39;/c/d/123.lab&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">sublist2</span>
<span class="go">[&#39;/g/h/xyz.npy&#39;, &#39;/i/j/123.txt&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.util.merge_labeled_intervals">
<span class="sig-prename descclassname"><span class="pre">mir_eval.util.</span></span><span class="sig-name descname"><span class="pre">merge_labeled_intervals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_labels</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.merge_labeled_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge the time intervals of two sequences.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x_intervals</strong><span class="classifier">np.ndarray</span></dt><dd><p>Array of interval times (seconds)</p>
</dd>
<dt><strong>x_labels</strong><span class="classifier">list or None</span></dt><dd><p>List of labels</p>
</dd>
<dt><strong>y_intervals</strong><span class="classifier">np.ndarray</span></dt><dd><p>Array of interval times (seconds)</p>
</dd>
<dt><strong>y_labels</strong><span class="classifier">list or None</span></dt><dd><p>List of labels</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>new_intervals</strong><span class="classifier">np.ndarray</span></dt><dd><p>New interval times of the merged sequences.</p>
</dd>
<dt><strong>new_x_labels</strong><span class="classifier">list</span></dt><dd><p>New labels for the sequence <code class="docutils literal notranslate"><span class="pre">x</span></code></p>
</dd>
<dt><strong>new_y_labels</strong><span class="classifier">list</span></dt><dd><p>New labels for the sequence <code class="docutils literal notranslate"><span class="pre">y</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.util.match_events">
<span class="sig-prename descclassname"><span class="pre">mir_eval.util.</span></span><span class="sig-name descname"><span class="pre">match_events</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.match_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a maximum matching between reference and estimated event times,
subject to a window constraint.</p>
<p>Given two lists of event times <code class="docutils literal notranslate"><span class="pre">ref</span></code> and <code class="docutils literal notranslate"><span class="pre">est</span></code>, we seek the largest set
of correspondences <code class="docutils literal notranslate"><span class="pre">(ref[i],</span> <span class="pre">est[j])</span></code> such that
<code class="docutils literal notranslate"><span class="pre">distance(ref[i],</span> <span class="pre">est[j])</span> <span class="pre">&lt;=</span> <span class="pre">window</span></code>, and each
<code class="docutils literal notranslate"><span class="pre">ref[i]</span></code> and <code class="docutils literal notranslate"><span class="pre">est[j]</span></code> is matched at most once.</p>
<p>This is useful for computing precision/recall metrics in beat tracking,
onset detection, and segmentation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ref</strong><span class="classifier">np.ndarray, shape=(n,)</span></dt><dd><p>Array of reference values</p>
</dd>
<dt><strong>est</strong><span class="classifier">np.ndarray, shape=(m,)</span></dt><dd><p>Array of estimated values</p>
</dd>
<dt><strong>window</strong><span class="classifier">float &gt; 0</span></dt><dd><p>Size of the window.</p>
</dd>
<dt><strong>distance</strong><span class="classifier">function</span></dt><dd><p>function that computes the outer distance of ref and est.
By default uses <code class="docutils literal notranslate"><span class="pre">|ref[i]</span> <span class="pre">-</span> <span class="pre">est[j]|</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>matching</strong><span class="classifier">list of tuples</span></dt><dd><p>A list of matched reference and event numbers.
<code class="docutils literal notranslate"><span class="pre">matching[i]</span> <span class="pre">==</span> <span class="pre">(i,</span> <span class="pre">j)</span></code> where <code class="docutils literal notranslate"><span class="pre">ref[i]</span></code> matches <code class="docutils literal notranslate"><span class="pre">est[j]</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.util.validate_intervals">
<span class="sig-prename descclassname"><span class="pre">mir_eval.util.</span></span><span class="sig-name descname"><span class="pre">validate_intervals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intervals</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.validate_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that an (n, 2) interval ndarray is well-formed, and raises errors
if not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>intervals</strong><span class="classifier">np.ndarray, shape=(n, 2)</span></dt><dd><p>Array of interval start/end locations.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.util.validate_events">
<span class="sig-prename descclassname"><span class="pre">mir_eval.util.</span></span><span class="sig-name descname"><span class="pre">validate_events</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">events</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">30000.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.validate_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that a 1-d event location ndarray is well-formed, and raises
errors if not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>events</strong><span class="classifier">np.ndarray, shape=(n,)</span></dt><dd><p>Array of event times</p>
</dd>
<dt><strong>max_time</strong><span class="classifier">float</span></dt><dd><p>If an event is found above this time, a ValueError will be raised.
(Default value = 30000.)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.util.validate_frequencies">
<span class="sig-prename descclassname"><span class="pre">mir_eval.util.</span></span><span class="sig-name descname"><span class="pre">validate_frequencies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frequencies</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_negatives</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.validate_frequencies" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that a 1-d frequency ndarray is well-formed, and raises
errors if not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>frequencies</strong><span class="classifier">np.ndarray, shape=(n,)</span></dt><dd><p>Array of frequency values</p>
</dd>
<dt><strong>max_freq</strong><span class="classifier">float</span></dt><dd><p>If a frequency is found above this pitch, a ValueError will be raised.
(Default value = 5000.)</p>
</dd>
<dt><strong>min_freq</strong><span class="classifier">float</span></dt><dd><p>If a frequency is found below this pitch, a ValueError will be raised.
(Default value = 20.)</p>
</dd>
<dt><strong>allow_negatives</strong><span class="classifier">bool</span></dt><dd><p>Whether or not to allow negative frequency values.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.util.has_kwargs">
<span class="sig-prename descclassname"><span class="pre">mir_eval.util.</span></span><span class="sig-name descname"><span class="pre">has_kwargs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.has_kwargs" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine whether a function has **kwargs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>function</strong><span class="classifier">callable</span></dt><dd><p>The function to test</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>True if function accepts arbitrary keyword arguments.</dt><dd></dd>
<dt>False otherwise.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.util.filter_kwargs">
<span class="sig-prename descclassname"><span class="pre">mir_eval.util.</span></span><span class="sig-name descname"><span class="pre">filter_kwargs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">_function</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.filter_kwargs" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a function and args and keyword args to pass to it, call the function
but using only the keyword arguments which it accepts.  This is equivalent
to redefining the function with an additional **kwargs to accept slop
keyword args.</p>
<p>If the target function already accepts **kwargs parameters, no filtering
is performed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>_function</strong><span class="classifier">callable</span></dt><dd><p>Function to call.  Can take in any number of args or kwargs</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.util.intervals_to_durations">
<span class="sig-prename descclassname"><span class="pre">mir_eval.util.</span></span><span class="sig-name descname"><span class="pre">intervals_to_durations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intervals</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.intervals_to_durations" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts an array of n intervals to their n durations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>intervals</strong><span class="classifier">np.ndarray, shape=(n, 2)</span></dt><dd><p>An array of time intervals, as returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_intervals()</span></code></a>.
The <code class="docutils literal notranslate"><span class="pre">i</span></code> th interval spans time <code class="docutils literal notranslate"><span class="pre">intervals[i,</span> <span class="pre">0]</span></code> to
<code class="docutils literal notranslate"><span class="pre">intervals[i,</span> <span class="pre">1]</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>durations</strong><span class="classifier">np.ndarray, shape=(n,)</span></dt><dd><p>Array of the duration of each interval.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.util.hz_to_midi">
<span class="sig-prename descclassname"><span class="pre">mir_eval.util.</span></span><span class="sig-name descname"><span class="pre">hz_to_midi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">freqs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.hz_to_midi" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Hz to MIDI numbers</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>freqs</strong><span class="classifier">number or ndarray</span></dt><dd><p>Frequency/frequencies in Hz</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>midi</strong><span class="classifier">number or ndarray</span></dt><dd><p>MIDI note numbers corresponding to input frequencies.
Note that these may be fractional.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.util.midi_to_hz">
<span class="sig-prename descclassname"><span class="pre">mir_eval.util.</span></span><span class="sig-name descname"><span class="pre">midi_to_hz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">midi</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.midi_to_hz" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert MIDI numbers to Hz</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>midi</strong><span class="classifier">number or ndarray</span></dt><dd><p>MIDI notes</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>freqs</strong><span class="classifier">number or ndarray</span></dt><dd><p>Frequency/frequencies in Hz corresponding to <cite>midi</cite></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-mir_eval.io">
<span id="mir-eval-io"></span><h3><a class="reference internal" href="#module-mir_eval.io" title="mir_eval.io"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.io</span></code></a><a class="headerlink" href="#module-mir_eval.io" title="Permalink to this headline">¶</a></h3>
<p>Functions for loading in annotations from files in different formats.</p>
<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.io.load_delimited">
<span class="sig-prename descclassname"><span class="pre">mir_eval.io.</span></span><span class="sig-name descname"><span class="pre">load_delimited</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">converters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delimiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'\\s+'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'#'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_delimited" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility function for loading in data from an annotation file where columns
are delimited.  The number of columns is inferred from the length of
the provided converters list.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>Path to the annotation file</p>
</dd>
<dt><strong>converters</strong><span class="classifier">list of functions</span></dt><dd><p>Each entry in column <code class="docutils literal notranslate"><span class="pre">n</span></code> of the file will be cast by the function
<code class="docutils literal notranslate"><span class="pre">converters[n]</span></code>.</p>
</dd>
<dt><strong>delimiter</strong><span class="classifier">str</span></dt><dd><p>Separator regular expression.
By default, lines will be split by any amount of whitespace.</p>
</dd>
<dt><strong>comment</strong><span class="classifier">str or None</span></dt><dd><p>Comment regular expression.
Any lines beginning with this string or pattern will be ignored.</p>
<p>Setting to <cite>None</cite> disables comments.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>columns</strong><span class="classifier">tuple of lists</span></dt><dd><p>Each list in this tuple corresponds to values in one of the columns
in the file.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Load in a one-column list of event times (floats)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">load_delimited</span><span class="p">(</span><span class="s1">&#39;events.txt&#39;</span><span class="p">,</span> <span class="p">[</span><span class="nb">float</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Load in a list of labeled events, separated by commas</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">load_delimited</span><span class="p">(</span><span class="s1">&#39;labeled_events.csv&#39;</span><span class="p">,</span> <span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="s1">&#39;,&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.io.load_events">
<span class="sig-prename descclassname"><span class="pre">mir_eval.io.</span></span><span class="sig-name descname"><span class="pre">load_events</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delimiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'\\s+'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'#'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Import time-stamp events from an annotation file.  The file should
consist of a single column of numeric values corresponding to the event
times. This is primarily useful for processing events which lack duration,
such as beats or onsets.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>Path to the annotation file</p>
</dd>
<dt><strong>delimiter</strong><span class="classifier">str</span></dt><dd><p>Separator regular expression.
By default, lines will be split by any amount of whitespace.</p>
</dd>
<dt><strong>comment</strong><span class="classifier">str or None</span></dt><dd><p>Comment regular expression.
Any lines beginning with this string or pattern will be ignored.</p>
<p>Setting to <cite>None</cite> disables comments.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>event_times</strong><span class="classifier">np.ndarray</span></dt><dd><p>array of event times (float)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.io.load_labeled_events">
<span class="sig-prename descclassname"><span class="pre">mir_eval.io.</span></span><span class="sig-name descname"><span class="pre">load_labeled_events</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delimiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'\\s+'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'#'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_labeled_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Import labeled time-stamp events from an annotation file.  The file should
consist of two columns; the first having numeric values corresponding to
the event times and the second having string labels for each event.  This
is primarily useful for processing labeled events which lack duration, such
as beats with metric beat number or onsets with an instrument label.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>Path to the annotation file</p>
</dd>
<dt><strong>delimiter</strong><span class="classifier">str</span></dt><dd><p>Separator regular expression.
By default, lines will be split by any amount of whitespace.</p>
</dd>
<dt><strong>comment</strong><span class="classifier">str or None</span></dt><dd><p>Comment regular expression.
Any lines beginning with this string or pattern will be ignored.</p>
<p>Setting to <cite>None</cite> disables comments.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>event_times</strong><span class="classifier">np.ndarray</span></dt><dd><p>array of event times (float)</p>
</dd>
<dt><strong>labels</strong><span class="classifier">list of str</span></dt><dd><p>list of labels</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.io.load_intervals">
<span class="sig-prename descclassname"><span class="pre">mir_eval.io.</span></span><span class="sig-name descname"><span class="pre">load_intervals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delimiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'\\s+'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'#'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Import intervals from an annotation file.  The file should consist of two
columns of numeric values corresponding to start and end time of each
interval.  This is primarily useful for processing events which span a
duration, such as segmentation, chords, or instrument activation.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>Path to the annotation file</p>
</dd>
<dt><strong>delimiter</strong><span class="classifier">str</span></dt><dd><p>Separator regular expression.
By default, lines will be split by any amount of whitespace.</p>
</dd>
<dt><strong>comment</strong><span class="classifier">str or None</span></dt><dd><p>Comment regular expression.
Any lines beginning with this string or pattern will be ignored.</p>
<p>Setting to <cite>None</cite> disables comments.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>intervals</strong><span class="classifier">np.ndarray, shape=(n_events, 2)</span></dt><dd><p>array of event start and end times</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.io.load_labeled_intervals">
<span class="sig-prename descclassname"><span class="pre">mir_eval.io.</span></span><span class="sig-name descname"><span class="pre">load_labeled_intervals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delimiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'\\s+'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'#'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_labeled_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Import labeled intervals from an annotation file.  The file should consist
of three columns: Two consisting of numeric values corresponding to start
and end time of each interval and a third corresponding to the label of
each interval.  This is primarily useful for processing events which span a
duration, such as segmentation, chords, or instrument activation.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>Path to the annotation file</p>
</dd>
<dt><strong>delimiter</strong><span class="classifier">str</span></dt><dd><p>Separator regular expression.
By default, lines will be split by any amount of whitespace.</p>
</dd>
<dt><strong>comment</strong><span class="classifier">str or None</span></dt><dd><p>Comment regular expression.
Any lines beginning with this string or pattern will be ignored.</p>
<p>Setting to <cite>None</cite> disables comments.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>intervals</strong><span class="classifier">np.ndarray, shape=(n_events, 2)</span></dt><dd><p>array of event start and end time</p>
</dd>
<dt><strong>labels</strong><span class="classifier">list of str</span></dt><dd><p>list of labels</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.io.load_time_series">
<span class="sig-prename descclassname"><span class="pre">mir_eval.io.</span></span><span class="sig-name descname"><span class="pre">load_time_series</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delimiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'\\s+'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'#'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_time_series" title="Permalink to this definition">¶</a></dt>
<dd><p>Import a time series from an annotation file.  The file should consist of
two columns of numeric values corresponding to the time and value of each
sample of the time series.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>Path to the annotation file</p>
</dd>
<dt><strong>delimiter</strong><span class="classifier">str</span></dt><dd><p>Separator regular expression.
By default, lines will be split by any amount of whitespace.</p>
</dd>
<dt><strong>comment</strong><span class="classifier">str or None</span></dt><dd><p>Comment regular expression.
Any lines beginning with this string or pattern will be ignored.</p>
<p>Setting to <cite>None</cite> disables comments.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>times</strong><span class="classifier">np.ndarray</span></dt><dd><p>array of timestamps (float)</p>
</dd>
<dt><strong>values</strong><span class="classifier">np.ndarray</span></dt><dd><p>array of corresponding numeric values (float)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.io.load_patterns">
<span class="sig-prename descclassname"><span class="pre">mir_eval.io.</span></span><span class="sig-name descname"><span class="pre">load_patterns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_patterns" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads the patters contained in the filename and puts them into a list
of patterns, each pattern being a list of occurrence, and each
occurrence being a list of (onset, midi) pairs.</p>
<p>The input file must be formatted as described in MIREX 2013:
<a class="reference external" href="http://www.music-ir.org/mirex/wiki/2013:Discovery_of_Repeated_Themes_%26_Sections">http://www.music-ir.org/mirex/wiki/2013:Discovery_of_Repeated_Themes_%26_Sections</a></p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>The input file path containing the patterns of a given piece using the
MIREX 2013 format.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>pattern_list</strong><span class="classifier">list</span></dt><dd><p>The list of patterns, containing all their occurrences,
using the following format:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">onset_midi</span> <span class="o">=</span> <span class="p">(</span><span class="n">onset_time</span><span class="p">,</span> <span class="n">midi_number</span><span class="p">)</span>
<span class="n">occurrence</span> <span class="o">=</span> <span class="p">[</span><span class="n">onset_midi1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">onset_midiO</span><span class="p">]</span>
<span class="n">pattern</span> <span class="o">=</span> <span class="p">[</span><span class="n">occurrence1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">occurrenceM</span><span class="p">]</span>
<span class="n">pattern_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">pattern1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">patternN</span><span class="p">]</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">N</span></code> is the number of patterns, <code class="docutils literal notranslate"><span class="pre">M[i]</span></code> is the number of
occurrences of the <code class="docutils literal notranslate"><span class="pre">i</span></code> th pattern, and <code class="docutils literal notranslate"><span class="pre">O[j]</span></code> is the number of
onsets in the <code class="docutils literal notranslate"><span class="pre">j</span></code>’th occurrence.  E.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">occ1</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">64.0</span><span class="p">)]</span>
<span class="n">occ2</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">4.5</span><span class="p">,</span> <span class="mf">65.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">65.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">5.5</span><span class="p">,</span> <span class="mf">65.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">6.0</span><span class="p">,</span> <span class="mf">62.0</span><span class="p">)]</span>
<span class="n">pattern1</span> <span class="o">=</span> <span class="p">[</span><span class="n">occ1</span><span class="p">,</span> <span class="n">occ2</span><span class="p">]</span>

<span class="n">occ1</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">10.5</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">11.0</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">11.5</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">12.0</span><span class="p">,</span> <span class="mf">64.0</span><span class="p">),</span>
        <span class="p">(</span><span class="mf">12.5</span><span class="p">,</span> <span class="mf">69.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">13.0</span><span class="p">,</span> <span class="mf">69.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">13.5</span><span class="p">,</span> <span class="mf">69.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">14.0</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span>
        <span class="p">(</span><span class="mf">14.5</span><span class="p">,</span> <span class="mf">76.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">15.0</span><span class="p">,</span> <span class="mf">76.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">15.5</span><span class="p">,</span> <span class="mf">76.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">16.0</span><span class="p">,</span> <span class="mf">72.0</span><span class="p">)]</span>
<span class="n">occ2</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">18.5</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">19.0</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">19.5</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">20.0</span><span class="p">,</span> <span class="mf">62.0</span><span class="p">),</span>
        <span class="p">(</span><span class="mf">20.5</span><span class="p">,</span> <span class="mf">69.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">21.0</span><span class="p">,</span> <span class="mf">69.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">21.5</span><span class="p">,</span> <span class="mf">69.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">22.0</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span>
        <span class="p">(</span><span class="mf">22.5</span><span class="p">,</span> <span class="mf">77.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">23.0</span><span class="p">,</span> <span class="mf">77.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">23.5</span><span class="p">,</span> <span class="mf">77.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">24.0</span><span class="p">,</span> <span class="mf">74.0</span><span class="p">)]</span>
<span class="n">pattern2</span> <span class="o">=</span> <span class="p">[</span><span class="n">occ1</span><span class="p">,</span> <span class="n">occ2</span><span class="p">]</span>

<span class="n">pattern_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">pattern1</span><span class="p">,</span> <span class="n">pattern2</span><span class="p">]</span>
</pre></div>
</div>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.io.load_wav">
<span class="sig-prename descclassname"><span class="pre">mir_eval.io.</span></span><span class="sig-name descname"><span class="pre">load_wav</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mono</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_wav" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads a .wav file as a numpy array using <code class="docutils literal notranslate"><span class="pre">scipy.io.wavfile</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path</strong><span class="classifier">str</span></dt><dd><p>Path to a .wav file</p>
</dd>
<dt><strong>mono</strong><span class="classifier">bool</span></dt><dd><p>If the provided .wav has more than one channel, it will be
converted to mono if <code class="docutils literal notranslate"><span class="pre">mono=True</span></code>. (Default value = True)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>audio_data</strong><span class="classifier">np.ndarray</span></dt><dd><p>Array of audio samples, normalized to the range [-1., 1.]</p>
</dd>
<dt><strong>fs</strong><span class="classifier">int</span></dt><dd><p>Sampling rate of the audio data</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.io.load_valued_intervals">
<span class="sig-prename descclassname"><span class="pre">mir_eval.io.</span></span><span class="sig-name descname"><span class="pre">load_valued_intervals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delimiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'\\s+'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'#'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_valued_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Import valued intervals from an annotation file. The file should
consist of three columns: Two consisting of numeric values corresponding to
start and end time of each interval and a third, also of numeric values,
corresponding to the value of each interval. This is primarily useful for
processing events which span a duration and have a numeric value, such as
piano-roll notes which have an onset, offset, and a pitch value.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>Path to the annotation file</p>
</dd>
<dt><strong>delimiter</strong><span class="classifier">str</span></dt><dd><p>Separator regular expression.
By default, lines will be split by any amount of whitespace.</p>
</dd>
<dt><strong>comment</strong><span class="classifier">str or None</span></dt><dd><p>Comment regular expression.
Any lines beginning with this string or pattern will be ignored.</p>
<p>Setting to <cite>None</cite> disables comments.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>intervals</strong><span class="classifier">np.ndarray, shape=(n_events, 2)</span></dt><dd><p>Array of event start and end times</p>
</dd>
<dt><strong>values</strong><span class="classifier">np.ndarray, shape=(n_events,)</span></dt><dd><p>Array of values</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.io.load_key">
<span class="sig-prename descclassname"><span class="pre">mir_eval.io.</span></span><span class="sig-name descname"><span class="pre">load_key</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delimiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'\\s+'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'#'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Load key labels from an annotation file. The file should
consist of two string columns: One denoting the key scale degree
(semitone), and the other denoting the mode (major or minor).  The file
should contain only one row.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>Path to the annotation file</p>
</dd>
<dt><strong>delimiter</strong><span class="classifier">str</span></dt><dd><p>Separator regular expression.
By default, lines will be split by any amount of whitespace.</p>
</dd>
<dt><strong>comment</strong><span class="classifier">str or None</span></dt><dd><p>Comment regular expression.
Any lines beginning with this string or pattern will be ignored.</p>
<p>Setting to <cite>None</cite> disables comments.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>key</strong><span class="classifier">str</span></dt><dd><p>Key label, in the form <code class="docutils literal notranslate"><span class="pre">'(key)</span> <span class="pre">(mode)'</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.io.load_tempo">
<span class="sig-prename descclassname"><span class="pre">mir_eval.io.</span></span><span class="sig-name descname"><span class="pre">load_tempo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delimiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'\\s+'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'#'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_tempo" title="Permalink to this definition">¶</a></dt>
<dd><p>Load tempo estimates from an annotation file in MIREX format.
The file should consist of three numeric columns: the first two
correspond to tempo estimates (in beats-per-minute), and the third
denotes the relative confidence of the first value compared to the
second (in the range [0, 1]). The file should contain only one row.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>Path to the annotation file</p>
</dd>
<dt><strong>delimiter</strong><span class="classifier">str</span></dt><dd><p>Separator regular expression.
By default, lines will be split by any amount of whitespace.</p>
</dd>
<dt><strong>comment</strong><span class="classifier">str or None</span></dt><dd><p>Comment regular expression.
Any lines beginning with this string or pattern will be ignored.</p>
<p>Setting to <cite>None</cite> disables comments.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tempi</strong><span class="classifier">np.ndarray, non-negative</span></dt><dd><p>The two tempo estimates</p>
</dd>
<dt><strong>weight</strong><span class="classifier">float [0, 1]</span></dt><dd><p>The relative importance of <code class="docutils literal notranslate"><span class="pre">tempi[0]</span></code> compared to <code class="docutils literal notranslate"><span class="pre">tempi[1]</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.io.load_ragged_time_series">
<span class="sig-prename descclassname"><span class="pre">mir_eval.io.</span></span><span class="sig-name descname"><span class="pre">load_ragged_time_series</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'float'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delimiter='\\s+'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">header=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment='#'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_ragged_time_series" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility function for loading in data from a delimited time series
annotation file with a variable number of columns.
Assumes that column 0 contains time stamps and columns 1 through n contain
values. n may be variable from time stamp to time stamp.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>Path to the annotation file</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">function</span></dt><dd><p>Data type to apply to values columns.</p>
</dd>
<dt><strong>delimiter</strong><span class="classifier">str</span></dt><dd><p>Separator regular expression.
By default, lines will be split by any amount of whitespace.</p>
</dd>
<dt><strong>header</strong><span class="classifier">bool</span></dt><dd><p>Indicates whether a header row is present or not.
By default, assumes no header is present.</p>
</dd>
<dt><strong>comment</strong><span class="classifier">str or None</span></dt><dd><p>Comment regular expression.
Any lines beginning with this string or pattern will be ignored.</p>
<p>Setting to <cite>None</cite> disables comments.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>times</strong><span class="classifier">np.ndarray</span></dt><dd><p>array of timestamps (float)</p>
</dd>
<dt><strong>values</strong><span class="classifier">list of np.ndarray</span></dt><dd><p>list of arrays of corresponding values</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Load a ragged list of tab-delimited multi-f0 midi notes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">times</span><span class="p">,</span> <span class="n">vals</span> <span class="o">=</span> <span class="n">load_ragged_time_series</span><span class="p">(</span><span class="s1">&#39;multif0.txt&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
<span class="go">                                          delimiter=&#39;\t&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Load a raggled list of space delimited multi-f0 values with a header</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">times</span><span class="p">,</span> <span class="n">vals</span> <span class="o">=</span> <span class="n">load_ragged_time_series</span><span class="p">(</span><span class="s1">&#39;labeled_events.csv&#39;</span><span class="p">,</span>
<span class="go">                                          header=True)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-mir_eval.sonify">
<span id="mir-eval-sonify"></span><h3><a class="reference internal" href="#module-mir_eval.sonify" title="mir_eval.sonify"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.sonify</span></code></a><a class="headerlink" href="#module-mir_eval.sonify" title="Permalink to this headline">¶</a></h3>
<p>Methods which sonify annotations for “evaluation by ear”.
All functions return a raw signal at the specified sampling rate.</p>
<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.sonify.clicks">
<span class="sig-prename descclassname"><span class="pre">mir_eval.sonify.</span></span><span class="sig-name descname"><span class="pre">clicks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">click</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.sonify.clicks" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a signal with the signal ‘click’ placed at each specified time</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>times</strong><span class="classifier">np.ndarray</span></dt><dd><p>times to place clicks, in seconds</p>
</dd>
<dt><strong>fs</strong><span class="classifier">int</span></dt><dd><p>desired sampling rate of the output signal</p>
</dd>
<dt><strong>click</strong><span class="classifier">np.ndarray</span></dt><dd><p>click signal, defaults to a 1 kHz blip</p>
</dd>
<dt><strong>length</strong><span class="classifier">int</span></dt><dd><p>desired number of samples in the output signal,
defaults to <code class="docutils literal notranslate"><span class="pre">times.max()*fs</span> <span class="pre">+</span> <span class="pre">click.shape[0]</span> <span class="pre">+</span> <span class="pre">1</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>click_signal</strong><span class="classifier">np.ndarray</span></dt><dd><p>Synthesized click signal</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.sonify.time_frequency">
<span class="sig-prename descclassname"><span class="pre">mir_eval.sonify.</span></span><span class="sig-name descname"><span class="pre">time_frequency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gram</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequencies</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function=&lt;ufunc</span> <span class="pre">'sin'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_dec=1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.sonify.time_frequency" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse synthesis of a time-frequency representation of a signal</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>gram</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">gram[n,</span> <span class="pre">m]</span></code> is the magnitude of <code class="docutils literal notranslate"><span class="pre">frequencies[n]</span></code>
from <code class="docutils literal notranslate"><span class="pre">times[m]</span></code> to <code class="docutils literal notranslate"><span class="pre">times[m</span> <span class="pre">+</span> <span class="pre">1]</span></code></p>
<p>Non-positive magnitudes are interpreted as silence.</p>
</dd>
<dt><strong>frequencies</strong><span class="classifier">np.ndarray</span></dt><dd><p>array of size <code class="docutils literal notranslate"><span class="pre">gram.shape[0]</span></code> denoting the frequency of
each row of gram</p>
</dd>
<dt><strong>times</strong><span class="classifier">np.ndarray, shape= <code class="docutils literal notranslate"><span class="pre">(gram.shape[1],)</span></code> or <code class="docutils literal notranslate"><span class="pre">(gram.shape[1],</span> <span class="pre">2)</span></code></span></dt><dd><p>Either the start time of each column in the gram,
or the time interval corresponding to each column.</p>
</dd>
<dt><strong>fs</strong><span class="classifier">int</span></dt><dd><p>desired sampling rate of the output signal</p>
</dd>
<dt><strong>function</strong><span class="classifier">function</span></dt><dd><p>function to use to synthesize notes, should be <span class="math">2\pi</span>-periodic</p>
</dd>
<dt><strong>length</strong><span class="classifier">int</span></dt><dd><p>desired number of samples in the output signal,
defaults to <code class="docutils literal notranslate"><span class="pre">times[-1]*fs</span></code></p>
</dd>
<dt><strong>n_dec</strong><span class="classifier">int</span></dt><dd><p>the number of decimals used to approximate each sonfied frequency.
Defaults to 1 decimal place. Higher precision will be slower.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">np.ndarray</span></dt><dd><p>synthesized version of the piano roll</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.sonify.pitch_contour">
<span class="sig-prename descclassname"><span class="pre">mir_eval.sonify.</span></span><span class="sig-name descname"><span class="pre">pitch_contour</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequencies</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amplitudes=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function=&lt;ufunc</span> <span class="pre">'sin'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind='linear'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.sonify.pitch_contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Sonify a pitch contour.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>times</strong><span class="classifier">np.ndarray</span></dt><dd><p>time indices for each frequency measurement, in seconds</p>
</dd>
<dt><strong>frequencies</strong><span class="classifier">np.ndarray</span></dt><dd><p>frequency measurements, in Hz.
Non-positive measurements will be interpreted as un-voiced samples.</p>
</dd>
<dt><strong>fs</strong><span class="classifier">int</span></dt><dd><p>desired sampling rate of the output signal</p>
</dd>
<dt><strong>amplitudes</strong><span class="classifier">np.ndarray</span></dt><dd><p>amplitude measurments, nonnegative
defaults to <code class="docutils literal notranslate"><span class="pre">np.ones((length,))</span></code></p>
</dd>
<dt><strong>function</strong><span class="classifier">function</span></dt><dd><p>function to use to synthesize notes, should be <span class="math">2\pi</span>-periodic</p>
</dd>
<dt><strong>length</strong><span class="classifier">int</span></dt><dd><p>desired number of samples in the output signal,
defaults to <code class="docutils literal notranslate"><span class="pre">max(times)*fs</span></code></p>
</dd>
<dt><strong>kind</strong><span class="classifier">str</span></dt><dd><p>Interpolation mode for the frequency and amplitude values.
See: <code class="docutils literal notranslate"><span class="pre">scipy.interpolate.interp1d</span></code> for valid settings.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">np.ndarray</span></dt><dd><p>synthesized version of the pitch contour</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.sonify.chroma">
<span class="sig-prename descclassname"><span class="pre">mir_eval.sonify.</span></span><span class="sig-name descname"><span class="pre">chroma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chromagram</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.sonify.chroma" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse synthesis of a chromagram (semitone matrix)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>chromagram</strong><span class="classifier">np.ndarray, shape=(12, times.shape[0])</span></dt><dd><p>Chromagram matrix, where each row represents a semitone [C-&gt;Bb]
i.e., <code class="docutils literal notranslate"><span class="pre">chromagram[3,</span> <span class="pre">j]</span></code> is the magnitude of D# from <code class="docutils literal notranslate"><span class="pre">times[j]</span></code> to
<code class="docutils literal notranslate"><span class="pre">times[j</span> <span class="pre">+</span> <span class="pre">1]</span></code></p>
</dd>
<dt><strong>times: np.ndarray, shape=(len(chord_labels),) or (len(chord_labels), 2)</strong></dt><dd><p>Either the start time of each column in the chromagram,
or the time interval corresponding to each column.</p>
</dd>
<dt><strong>fs</strong><span class="classifier">int</span></dt><dd><p>Sampling rate to synthesize audio data at</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>Additional keyword arguments to pass to
<a class="reference internal" href="#mir_eval.sonify.time_frequency" title="mir_eval.sonify.time_frequency"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.sonify.time_frequency()</span></code></a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">np.ndarray</span></dt><dd><p>Synthesized chromagram</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.sonify.chords">
<span class="sig-prename descclassname"><span class="pre">mir_eval.sonify.</span></span><span class="sig-name descname"><span class="pre">chords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chord_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.sonify.chords" title="Permalink to this definition">¶</a></dt>
<dd><p>Synthesizes chord labels</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>chord_labels</strong><span class="classifier">list of str</span></dt><dd><p>List of chord label strings.</p>
</dd>
<dt><strong>intervals</strong><span class="classifier">np.ndarray, shape=(len(chord_labels), 2)</span></dt><dd><p>Start and end times of each chord label</p>
</dd>
<dt><strong>fs</strong><span class="classifier">int</span></dt><dd><p>Sampling rate to synthesize at</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>Additional keyword arguments to pass to
<a class="reference internal" href="#mir_eval.sonify.time_frequency" title="mir_eval.sonify.time_frequency"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.sonify.time_frequency()</span></code></a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">np.ndarray</span></dt><dd><p>Synthesized chord labels</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-mir_eval.display">
<span id="mir-eval-display"></span><h3><a class="reference internal" href="#module-mir_eval.display" title="mir_eval.display"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.display</span></code></a><a class="headerlink" href="#module-mir_eval.display" title="Permalink to this headline">¶</a></h3>
<p>Display functions</p>
<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.display.segments">
<span class="sig-prename descclassname"><span class="pre">mir_eval.display.</span></span><span class="sig-name descname"><span class="pre">segments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">height</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">text</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">text_kw</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.display.segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a segmentation as a set of disjoint rectangles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>intervals</strong><span class="classifier">np.ndarray, shape=(n, 2)</span></dt><dd><p>segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_intervals()</span></code></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>labels</strong><span class="classifier">list, shape=(n,)</span></dt><dd><p>reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>base</strong><span class="classifier">number</span></dt><dd><p>The vertical position of the base of the rectangles.
By default, this will be the bottom of the plot.</p>
</dd>
<dt><strong>height</strong><span class="classifier">number</span></dt><dd><p>The height of the rectangles.
By default, this will be the top of the plot (minus <code class="docutils literal notranslate"><span class="pre">base</span></code>).</p>
</dd>
<dt><strong>text</strong><span class="classifier">bool</span></dt><dd><p>If true, each segment’s label is displayed in its
upper-left corner</p>
</dd>
<dt><strong>text_kw</strong><span class="classifier">dict</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">text</span> <span class="pre">==</span> <span class="pre">True</span></code>, the properties of the text
object can be specified here.
See <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot.Text</span></code> for valid parameters</p>
</dd>
<dt><strong>ax</strong><span class="classifier">matplotlib.pyplot.axes</span></dt><dd><p>An axis handle on which to draw the segmentation.
If none is provided, a new set of axes is created.</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>Additional keyword arguments to pass to
<code class="docutils literal notranslate"><span class="pre">matplotlib.patches.Rectangle</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ax</strong><span class="classifier">matplotlib.pyplot.axes._subplots.AxesSubplot</span></dt><dd><p>A handle to the (possibly constructed) plot axes</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.display.labeled_intervals">
<span class="sig-prename descclassname"><span class="pre">mir_eval.display.</span></span><span class="sig-name descname"><span class="pre">labeled_intervals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label_set</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">height</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extend_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tick</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.display.labeled_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot labeled intervals with each label on its own row.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>intervals</strong><span class="classifier">np.ndarray, shape=(n, 2)</span></dt><dd><p>segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_intervals()</span></code></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>labels</strong><span class="classifier">list, shape=(n,)</span></dt><dd><p>reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</dd>
<dt><strong>label_set</strong><span class="classifier">list</span></dt><dd><p>An (ordered) list of labels to determine the plotting order.
If not provided, the labels will be inferred from
<code class="docutils literal notranslate"><span class="pre">ax.get_yticklabels()</span></code>.
If no <code class="docutils literal notranslate"><span class="pre">yticklabels</span></code> exist, then the sorted set of unique values
in <code class="docutils literal notranslate"><span class="pre">labels</span></code> is taken as the label set.</p>
</dd>
<dt><strong>base</strong><span class="classifier">np.ndarray, shape=(n,), optional</span></dt><dd><p>Vertical positions of each label.
By default, labels are positioned at integers
<code class="docutils literal notranslate"><span class="pre">np.arange(len(labels))</span></code>.</p>
</dd>
<dt><strong>height</strong><span class="classifier">scalar or np.ndarray, shape=(n,), optional</span></dt><dd><p>Height for each label.
If scalar, the same value is applied to all labels.
By default, each label has <code class="docutils literal notranslate"><span class="pre">height=1</span></code>.</p>
</dd>
<dt><strong>extend_labels</strong><span class="classifier">bool</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">False</span></code>, only values of <code class="docutils literal notranslate"><span class="pre">labels</span></code> that also exist in
<code class="docutils literal notranslate"><span class="pre">label_set</span></code> will be shown.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, all labels are shown, with those in <cite>labels</cite> but
not in <cite>label_set</cite> appended to the top of the plot.
A horizontal line is drawn to indicate the separation between
values in or out of <code class="docutils literal notranslate"><span class="pre">label_set</span></code>.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">matplotlib.pyplot.axes</span></dt><dd><p>An axis handle on which to draw the intervals.
If none is provided, a new set of axes is created.</p>
</dd>
<dt><strong>tick</strong><span class="classifier">bool</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, sets tick positions and labels on the y-axis.</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>Additional keyword arguments to pass to
<cite>matplotlib.collection.BrokenBarHCollection</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ax</strong><span class="classifier">matplotlib.pyplot.axes._subplots.AxesSubplot</span></dt><dd><p>A handle to the (possibly constructed) plot axes</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mir_eval.display.IntervalFormatter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mir_eval.display.</span></span><span class="sig-name descname"><span class="pre">IntervalFormatter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ticks</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.display.IntervalFormatter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.ticker.Formatter</span></code></p>
<p>Ticker formatter for labeled interval plots.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>base</strong><span class="classifier">array-like of int</span></dt><dd><p>The base positions of each label</p>
</dd>
<dt><strong>ticks</strong><span class="classifier">array-like of string</span></dt><dd><p>The labels for the ticks</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>axis</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(x[, pos])</p></td>
<td><p>Return the format for tick value <em>x</em> at position pos.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fix_minus</span></code>(s)</p></td>
<td><p>Some classes may want to replace a hyphen for minus with the proper unicode symbol (U+2212) for typographical correctness. This is a helper method to perform such a replacement when it is enabled via <a href="#id50"><span class="problematic" id="id51">:rc:`axes.unicode_minus`</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">format_data</span></code>(value)</p></td>
<td><p>Return the full string representation of the value with the position unspecified.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">format_data_short</span></code>(value)</p></td>
<td><p>Return a short string version of the tick value.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">format_ticks</span></code>(values)</p></td>
<td><p>Return the tick labels for all the ticks at once.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_locs</span></code>(locs)</p></td>
<td><p>Set the locations of the ticks.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 68%" />
<col style="width: 32%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>create_dummy_axis</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>get_offset</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>set_axis</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>set_bounds</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>set_data_interval</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>set_view_interval</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.display.hierarchy">
<span class="sig-prename descclassname"><span class="pre">mir_eval.display.</span></span><span class="sig-name descname"><span class="pre">hierarchy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intervals_hier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels_hier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">levels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.display.hierarchy" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a hierarchical segmentation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>intervals_hier</strong><span class="classifier">list of np.ndarray</span></dt><dd><p>A list of segmentation intervals.  Each element should be
an n-by-2 array of segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_intervals()</span></code></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.
Segmentations should be ordered by increasing specificity.</p>
</dd>
<dt><strong>labels_hier</strong><span class="classifier">list of list-like</span></dt><dd><p>A list of segmentation labels.  Each element should
be a list of labels for the corresponding element in
<cite>intervals_hier</cite>.</p>
</dd>
<dt><strong>levels</strong><span class="classifier">list of string</span></dt><dd><p>Each element <code class="docutils literal notranslate"><span class="pre">levels[i]</span></code> is a label for the <code class="docutils literal notranslate"><span class="pre">`i</span></code> th segmentation.
This is used in the legend to denote the levels in a segment hierarchy.</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>Additional keyword arguments to <cite>labeled_intervals</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ax</strong><span class="classifier">matplotlib.pyplot.axes._subplots.AxesSubplot</span></dt><dd><p>A handle to the (possibly constructed) plot axes</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.display.events">
<span class="sig-prename descclassname"><span class="pre">mir_eval.display.</span></span><span class="sig-name descname"><span class="pre">events</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">height</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">text_kw</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.display.events" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot event times as a set of vertical lines</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>times</strong><span class="classifier">np.ndarray, shape=(n,)</span></dt><dd><p>event times, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_events" title="mir_eval.io.load_events"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_events()</span></code></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_events" title="mir_eval.io.load_labeled_events"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_events()</span></code></a>.</p>
</dd>
<dt><strong>labels</strong><span class="classifier">list, shape=(n,), optional</span></dt><dd><p>event labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_events" title="mir_eval.io.load_labeled_events"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_labeled_events()</span></code></a>.</p>
</dd>
<dt><strong>base</strong><span class="classifier">number</span></dt><dd><p>The vertical position of the base of the line.
By default, this will be the bottom of the plot.</p>
</dd>
<dt><strong>height</strong><span class="classifier">number</span></dt><dd><p>The height of the lines.
By default, this will be the top of the plot (minus <cite>base</cite>).</p>
</dd>
<dt><strong>ax</strong><span class="classifier">matplotlib.pyplot.axes</span></dt><dd><p>An axis handle on which to draw the segmentation.
If none is provided, a new set of axes is created.</p>
</dd>
<dt><strong>text_kw</strong><span class="classifier">dict</span></dt><dd><p>If <cite>labels</cite> is provided, the properties of the text
objects can be specified here.
See <cite>matplotlib.pyplot.Text</cite> for valid parameters</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>Additional keyword arguments to pass to
<cite>matplotlib.pyplot.vlines</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ax</strong><span class="classifier">matplotlib.pyplot.axes._subplots.AxesSubplot</span></dt><dd><p>A handle to the (possibly constructed) plot axes</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.display.pitch">
<span class="sig-prename descclassname"><span class="pre">mir_eval.display.</span></span><span class="sig-name descname"><span class="pre">pitch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequencies</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">midi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unvoiced</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.display.pitch" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize pitch contours</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>times</strong><span class="classifier">np.ndarray, shape=(n,)</span></dt><dd><p>Sample times of frequencies</p>
</dd>
<dt><strong>frequencies</strong><span class="classifier">np.ndarray, shape=(n,)</span></dt><dd><p>frequencies (in Hz) of the pitch contours.
Voicing is indicated by sign (positive for voiced,
non-positive for non-voiced).</p>
</dd>
<dt><strong>midi</strong><span class="classifier">bool</span></dt><dd><p>If <cite>True</cite>, plot on a MIDI-numbered vertical axis.
Otherwise, plot on a linear frequency axis.</p>
</dd>
<dt><strong>unvoiced</strong><span class="classifier">bool</span></dt><dd><p>If <cite>True</cite>, unvoiced pitch contours are plotted and indicated
by transparency.</p>
<p>Otherwise, unvoiced pitch contours are omitted from the display.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">matplotlib.pyplot.axes</span></dt><dd><p>An axis handle on which to draw the pitch contours.
If none is provided, a new set of axes is created.</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>Additional keyword arguments to <cite>matplotlib.pyplot.plot</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ax</strong><span class="classifier">matplotlib.pyplot.axes._subplots.AxesSubplot</span></dt><dd><p>A handle to the (possibly constructed) plot axes</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.display.multipitch">
<span class="sig-prename descclassname"><span class="pre">mir_eval.display.</span></span><span class="sig-name descname"><span class="pre">multipitch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequencies</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">midi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unvoiced</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.display.multipitch" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize multiple f0 measurements</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>times</strong><span class="classifier">np.ndarray, shape=(n,)</span></dt><dd><p>Sample times of frequencies</p>
</dd>
<dt><strong>frequencies</strong><span class="classifier">list of np.ndarray</span></dt><dd><p>frequencies (in Hz) of the pitch measurements.
Voicing is indicated by sign (positive for voiced,
non-positive for non-voiced).</p>
<p><cite>times</cite> and <cite>frequencies</cite> should be in the format produced by
<a class="reference internal" href="#mir_eval.io.load_ragged_time_series" title="mir_eval.io.load_ragged_time_series"><code class="xref py py-func docutils literal notranslate"><span class="pre">mir_eval.io.load_ragged_time_series()</span></code></a></p>
</dd>
<dt><strong>midi</strong><span class="classifier">bool</span></dt><dd><p>If <cite>True</cite>, plot on a MIDI-numbered vertical axis.
Otherwise, plot on a linear frequency axis.</p>
</dd>
<dt><strong>unvoiced</strong><span class="classifier">bool</span></dt><dd><p>If <cite>True</cite>, unvoiced pitches are plotted and indicated
by transparency.</p>
<p>Otherwise, unvoiced pitches are omitted from the display.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">matplotlib.pyplot.axes</span></dt><dd><p>An axis handle on which to draw the pitch contours.
If none is provided, a new set of axes is created.</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>Additional keyword arguments to <cite>plt.scatter</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ax</strong><span class="classifier">matplotlib.pyplot.axes._subplots.AxesSubplot</span></dt><dd><p>A handle to the (possibly constructed) plot axes</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.display.piano_roll">
<span class="sig-prename descclassname"><span class="pre">mir_eval.display.</span></span><span class="sig-name descname"><span class="pre">piano_roll</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intervals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pitches</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">midi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.display.piano_roll" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a quantized piano roll as intervals</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>intervals</strong><span class="classifier">np.ndarray, shape=(n, 2)</span></dt><dd><p>timing intervals for notes</p>
</dd>
<dt><strong>pitches</strong><span class="classifier">np.ndarray, shape=(n,), optional</span></dt><dd><p>pitches of notes (in Hz).</p>
</dd>
<dt><strong>midi</strong><span class="classifier">np.ndarray, shape=(n,), optional</span></dt><dd><p>pitches of notes (in MIDI numbers).</p>
<p>At least one of <code class="docutils literal notranslate"><span class="pre">pitches</span></code> or <code class="docutils literal notranslate"><span class="pre">midi</span></code> must be provided.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">matplotlib.pyplot.axes</span></dt><dd><p>An axis handle on which to draw the intervals.
If none is provided, a new set of axes is created.</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>Additional keyword arguments to <a class="reference internal" href="#mir_eval.display.labeled_intervals" title="mir_eval.display.labeled_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">labeled_intervals()</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ax</strong><span class="classifier">matplotlib.pyplot.axes._subplots.AxesSubplot</span></dt><dd><p>A handle to the (possibly constructed) plot axes</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.display.separation">
<span class="sig-prename descclassname"><span class="pre">mir_eval.display.</span></span><span class="sig-name descname"><span class="pre">separation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sources</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">22050</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.75</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.display.separation" title="Permalink to this definition">¶</a></dt>
<dd><p>Source-separation visualization</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sources</strong><span class="classifier">np.ndarray, shape=(nsrc, nsampl)</span></dt><dd><p>A list of waveform buffers corresponding to each source</p>
</dd>
<dt><strong>fs</strong><span class="classifier">number &gt; 0</span></dt><dd><p>The sampling rate</p>
</dd>
<dt><strong>labels</strong><span class="classifier">list of strings</span></dt><dd><p>An optional list of descriptors corresponding to each source</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float in [0, 1]</span></dt><dd><p>Maximum alpha (opacity) of spectrogram values.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">matplotlib.pyplot.axes</span></dt><dd><p>An axis handle on which to draw the spectrograms.
If none is provided, a new set of axes is created.</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>Additional keyword arguments to <code class="docutils literal notranslate"><span class="pre">scipy.signal.spectrogram</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>ax</dt><dd><p>The axis handle for this plot</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.display.ticker_notes">
<span class="sig-prename descclassname"><span class="pre">mir_eval.display.</span></span><span class="sig-name descname"><span class="pre">ticker_notes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.display.ticker_notes" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the y-axis of the given axes to MIDI notes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ax</strong><span class="classifier">matplotlib.pyplot.axes</span></dt><dd><p>The axes handle to apply the ticker.
By default, uses the current axes handle.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mir_eval.display.ticker_pitch">
<span class="sig-prename descclassname"><span class="pre">mir_eval.display.</span></span><span class="sig-name descname"><span class="pre">ticker_pitch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.display.ticker_pitch" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the y-axis of the given axes to MIDI frequencies</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ax</strong><span class="classifier">matplotlib.pyplot.axes</span></dt><dd><p>The axes handle to apply the ticker.
By default, uses the current axes handle.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="changes">
<h2>Changes<a class="headerlink" href="#changes" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="changes.html">Changes</a></li>
</ul>
</div>
</section>
<section id="indices-and-tables">
<h2>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="#">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="docutils literal notranslate"><span class="pre">mir_eval</span></code> Documentation</a><ul>
<li><a class="reference internal" href="#installing-mir-eval">Installing <code class="docutils literal notranslate"><span class="pre">mir_eval</span></code></a></li>
<li><a class="reference internal" href="#using-mir-eval">Using <code class="docutils literal notranslate"><span class="pre">mir_eval</span></code></a></li>
<li><a class="reference internal" href="#mir-eval"><code class="docutils literal notranslate"><span class="pre">mir_eval</span></code></a><ul>
<li><a class="reference internal" href="#module-mir_eval.beat"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.beat</span></code></a><ul>
<li><a class="reference internal" href="#conventions">Conventions</a></li>
<li><a class="reference internal" href="#metrics">Metrics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.chord"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.chord</span></code></a><ul>
<li><a class="reference internal" href="#id2">Conventions</a></li>
<li><a class="reference internal" href="#id4">Metrics</a></li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.melody"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.melody</span></code></a><ul>
<li><a class="reference internal" href="#id6">Conventions</a></li>
<li><a class="reference internal" href="#id7">Metrics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.multipitch"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.multipitch</span></code></a><ul>
<li><a class="reference internal" href="#id11">Conventions</a></li>
<li><a class="reference internal" href="#id14">Metrics</a></li>
<li><a class="reference internal" href="#id15">References</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.onset"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.onset</span></code></a><ul>
<li><a class="reference internal" href="#id16">Conventions</a></li>
<li><a class="reference internal" href="#id17">Metrics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.pattern"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.pattern</span></code></a><ul>
<li><a class="reference internal" href="#id18">Conventions</a></li>
<li><a class="reference internal" href="#id19">Metrics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.segment"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.segment</span></code></a><ul>
<li><a class="reference internal" href="#id20">Conventions</a></li>
<li><a class="reference internal" href="#id21">Metrics</a></li>
<li><a class="reference internal" href="#id27">References</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.hierarchy"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.hierarchy</span></code></a><ul>
<li><a class="reference internal" href="#id28">Conventions</a></li>
<li><a class="reference internal" href="#id29">Metrics</a></li>
<li><a class="reference internal" href="#id30">References</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.separation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.separation</span></code></a><ul>
<li><a class="reference internal" href="#id33">Conventions</a></li>
<li><a class="reference internal" href="#id34">Metrics</a></li>
<li><a class="reference internal" href="#id35">References</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.tempo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.tempo</span></code></a><ul>
<li><a class="reference internal" href="#id40">Conventions</a></li>
<li><a class="reference internal" href="#id41">Metrics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.transcription"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.transcription</span></code></a><ul>
<li><a class="reference internal" href="#id42">Conventions</a></li>
<li><a class="reference internal" href="#id43">Metrics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.transcription_velocity"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.transcription_velocity</span></code></a><ul>
<li><a class="reference internal" href="#id45">Conventions</a></li>
<li><a class="reference internal" href="#id46">Metrics</a></li>
<li><a class="reference internal" href="#id47">References</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.key"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.key</span></code></a><ul>
<li><a class="reference internal" href="#id48">Conventions</a></li>
<li><a class="reference internal" href="#id49">Metrics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.util"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.util</span></code></a></li>
<li><a class="reference internal" href="#module-mir_eval.io"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.io</span></code></a></li>
<li><a class="reference internal" href="#module-mir_eval.sonify"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.sonify</span></code></a></li>
<li><a class="reference internal" href="#module-mir_eval.display"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mir_eval.display</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#changes">Changes</a></li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="changes.html"
                          title="next chapter">Changes</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/index.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="changes.html" title="Changes"
             >next</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">mir_eval 0.7 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="docutils literal notranslate"><span class="pre">mir_eval</span></code> Documentation</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2014, Colin Raffel et al..
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>
  </body>
</html>